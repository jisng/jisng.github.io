<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JTAppleCalendar Programmatically (3)</title>
    <link href="undefined2020/01/jtapplecalendar-programmatically-3/"/>
    <url>2020/01/jtapplecalendar-programmatically-3/</url>
    
    <content type="html"><![CDATA[<h1 id="JTAppleCalendar-사용하기-3-달력-헤더-월-표시"><a href="#JTAppleCalendar-사용하기-3-달력-헤더-월-표시" class="headerlink" title="JTAppleCalendar 사용하기 3 - 달력 헤더(월) 표시"></a>JTAppleCalendar 사용하기 3 - 달력 헤더(월) 표시</h1><img src="/2020/01/jtapplecalendar-programmatically-3/calender1.png" srcset="undefined" alt="calender1" style="zoom:50%;"><p>사진처럼 달력에 ‘월’을 표시합니다.</p><h2 id="DateHeader-swift"><a href="#DateHeader-swift" class="headerlink" title="DateHeader.swift"></a>DateHeader.swift</h2><pre><code class="swift">import JTAppleCalendarimport UIKitclass DateHeader: JTACMonthReusableView {    static let identifier = &quot;month&quot;    let dateHeader = UILabel()  override init(frame: CGRect) {      super.init(frame: frame)    baseUI()  }  required init?(coder aDecoder: NSCoder) {      fatalError(&quot;init(coder:) has not been implemented&quot;)  }  private func baseUI() {      dateHeader.textAlignment = .center    dateHeader.font = .systemFont(ofSize: 20, weight: .medium)    self.addSubview(dateHeader)    dateHeader.translatesAutoresizingMaskIntoConstraints = false    dateHeader.centerYAnchor.constraint(equalTo: self.centerYAnchor).isActive = true    dateHeader.centerXAnchor.constraint(equalTo: self.centerXAnchor).isActive = true  }}</code></pre><p>헤더 파일을 생성한 뒤, 커스텀 셀 만드는 것처럼 만듭니다.<br>withReuseIdentifier 를 문자열 그대로 입력하지 않고, identifier를 static하게 만든 후 사용하려고 합니다. (DateCell도 이렇게 만들 수 있겠죠!)</p><h2 id="MonthViewController-swift-JTACMonthViewDelegate"><a href="#MonthViewController-swift-JTACMonthViewDelegate" class="headerlink" title="MonthViewController.swift - JTACMonthViewDelegate"></a>MonthViewController.swift - JTACMonthViewDelegate</h2><pre><code class="swift">func calendar(_ calendar: JTACMonthView, headerViewForDateRange range: (start: Date, end: Date), at indexPath: IndexPath) -&gt; JTACMonthReusableView {    let formatter = DateFormatter()  formatter.dateFormat = &quot;y.M월&quot;  let header = calendar.dequeueReusableJTAppleSupplementaryView(withReuseIdentifier: DateHeader.identifier, for: indexPath) as! DateHeader  header.dateHeader.text = formatter.string(from: range.start)  header.backgroundColor = .lightGray  return header}func calendarSizeForMonths(_ calendar: JTACMonthView?) -&gt; MonthSize? {    return MonthSize(defaultSize: 50)}</code></pre><p>델리게이트에 위 두 개의 함수를 작성합니다. </p><ul><li><code>formatter.dateFormat</code> : 해당 월을 표현하는 방식이니 취향껏 구현하면 됩니다.<br>MMM = Jan, MM = 01, M = 1</li></ul><p>##MonthViewController.swift</p><pre><code class="swift">calenderView.register(DateHeader.self, forSupplementaryViewOfKind: UICollectionView.elementKindSectionHeader, withReuseIdentifier: DateHeader.identifier)</code></pre><p>헤더는 <code>func register(_:forSupplementaryViewOfKind:withReuseIdentifier:)</code> 이 함수를 이용해서 등록합니다. </p><br><p>실행해보면 헤더가 나타납니다! </p>]]></content>
    
    
    <categories>
      
      <category>TIL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>JTAppleCalendar</tag>
      
      <tag>Library</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JTAppleCalendar Programmatically (2)</title>
    <link href="undefined2020/01/jtapplecalendar-programmatically-2/"/>
    <url>2020/01/jtapplecalendar-programmatically-2/</url>
    
    <content type="html"><![CDATA[<h1 id="JTAppleCalendar-사용하기-2-날짜-선택-표시"><a href="#JTAppleCalendar-사용하기-2-날짜-선택-표시" class="headerlink" title="JTAppleCalendar 사용하기 2 - 날짜 선택 표시"></a>JTAppleCalendar 사용하기 2 - 날짜 선택 표시</h1><p>이번엔 날짜를 클릭했을 때, 날짜에 선택 표시를 띄워보도록 하겠습니다.  </p><p><img src="/2020/01/jtapplecalendar-programmatically-2/calender1.png" srcset="undefined" alt="calender1"></p><p>이런식으로요!</p><h2 id="DateCell-swift"><a href="#DateCell-swift" class="headerlink" title="DateCell.swift"></a>DateCell.swift</h2><pre><code class="swift">let selectedView = UIView()</code></pre><p>view 하나를 만들고</p><pre><code class="swift">selectedView.backgroundColor = .yellowselectedView.isHidden = true</code></pre><p>원하는 색상으로 백그라운드 설정한 후, 숨김처리를 해줍니다.</p><pre><code class="swift">contentView.addSubview(selectedView)contentView.addSubview(dateLabel)</code></pre><p>addSubView 하실 때 <strong>dateLabel 보다 먼저</strong> 해줘야 합니다. 나중에 하면 날짜를 가려버려요.</p><pre><code class="swift">selectedView.translatesAutoresizingMaskIntoConstraints = falseselectedView.widthAnchor.constraint(equalTo: contentView.widthAnchor).isActive = trueselectedView.heightAnchor.constraint(equalTo: selectedView.widthAnchor).isActive = trueselectedView.centerYAnchor.constraint(equalTo: dateLabel.centerYAnchor).isActive = trueselectedView.centerXAnchor.constraint(equalTo: dateLabel.centerXAnchor).isActive = true</code></pre><p>위치는 다음과 같이 잡아줍니다. width와 height 값은 여러번 바꿔보면서 마음에 드는 사이즈를 찾아보세요. </p><br><h2 id="MonthViewController-swift-JTACMonthViewDelegate"><a href="#MonthViewController-swift-JTACMonthViewDelegate" class="headerlink" title="MonthViewController.swift - JTACMonthViewDelegate"></a>MonthViewController.swift - JTACMonthViewDelegate</h2><pre><code class="swift">private func handleCellSelected(cell: DateCell, cellState: CellState) {    if cellState.isSelected {      cell.selectedView.layer.cornerRadius = cell.selectedView.frame.width/2    cell.selectedView.isHidden = false  } else {    cell.selectedView.isHidden = true  }}</code></pre><p>셀을 선택했을 때만 selectedView가 나타날 수 있도록 하는 하는 함수를 만들어줍니다.<br>오토레이아웃으로 위치가 잡힌 다음 cornerRadius를 줘야 하기 때문에, 이 코드도 이곳에 작성합니다.</p><pre><code class="swift">handleCellSelected(cell: cell, cellState: cellState)</code></pre><p>앞서 만들었던 <code>configureCell(view:cellState:)</code> 함수에 추가해줍니다. </p><pre><code class="swift">func calendar(_ calendar: JTACMonthView, didSelectDate date: Date, cell: JTACDayCell?, cellState: CellState, indexPath: IndexPath) {    configureCell(view: cell, cellState: cellState)}func calendar(_ calendar: JTACMonthView, didDeselectDate date: Date, cell: JTACDayCell?, cellState: CellState, indexPath: IndexPath) {    configureCell(view: cell, cellState: cellState)}</code></pre><p>델리게이트에 이미 있는 함수인 <code>didSelecDate</code>와 <code>didDeselectDate</code> 함수를 호출하여, 날짜를 눌렀을 때마다 해당 날짜에만 표시가 되도록 처리해줍니다.</p><br><p>실행해보시면, 누르는 날짜마다 노란 동그라미가 나타날 것입니다. </p><br><h3 id="shouldSelectDate"><a href="#shouldSelectDate" class="headerlink" title="(+) shouldSelectDate"></a>(+) shouldSelectDate</h3><p>델리게이트에 <code>shouldSelectDate</code> 함수를 호출하면, 조건에 의해서만 날짜가 선택될 수 있도록 처리할 수 있습니다. </p>]]></content>
    
    
    <categories>
      
      <category>TIL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>JTAppleCalendar</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JTAppleCalendar Programmatically (1)</title>
    <link href="undefined2020/01/jtapplecalendar-programmatically/"/>
    <url>2020/01/jtapplecalendar-programmatically/</url>
    
    <content type="html"><![CDATA[<h3 id="JTAppleCalendar-사용하기에-앞서-…"><a href="#JTAppleCalendar-사용하기에-앞서-…" class="headerlink" title="JTAppleCalendar 사용하기에 앞서 …"></a>JTAppleCalendar 사용하기에 앞서 …</h3><p>해커톤(이라 쓰고 프로젝트라 읽는) 기간에 가계부 앱을 구현하였는데, 이 때 일부 기능으로 캘린더를 구현하였습니다.<br>iOS 에서 캘린더 구현이 극악 난이도라고 하길래, 외부 라이브러리를 사용하였는데 캘린더는 라이브러리 갖다 쓰는 것도 쉽지 않았습니다 (…)<br>결과적으로 구현하긴 했지만, 제가 하자고 해놓고 다른 조원이 피땀흘려 구현해주셔서 ㅎㅎ..<br>이걸 제 것으로 만들기 위해 차분히 뜯어보며 튜토리얼을 블로그에 적고자 합니다.  </p><br><p>캘린더 라이브러리를 검색하면 대표적인 라이브러리가 몇 개 있습니다.<br>저희가 필요했던 라이브러리는 시간까지 다루는 “일정” 기능이 필요한 게 아니였고, 디자인을 자유롭게 만지길 원했습니다.<br>니즈에 딱 맞는 라이브러리면서 찾아보니 가장 유명해보이는(?) JTAppleCalendar 를 사용하기로 했습니다.  </p><p><a href="https://github.com/patchthecode/JTAppleCalendar" target="_blank" rel="noopener">JTAppleCalendar</a></p><br><p>들어가 보시면 Wiki 에 사용 방법이 모~두 나와 있..는 줄 알았는데,<br>스토리보드 사용법 + Wiki 업데이트 안함 .. 이라 달력 띄우는 것 부터 난항이었습니다.<br>그래도 스토리보드 사용을 원하시면 저 Wiki를 참고하는 것이 좋습니다. </p><hr><h1 id="JTAppleCalendar-사용하기-1-달력-띄우기"><a href="#JTAppleCalendar-사용하기-1-달력-띄우기" class="headerlink" title="JTAppleCalendar 사용하기 1 - 달력 띄우기"></a>JTAppleCalendar 사용하기 1 - 달력 띄우기</h1><h2 id="import-JTAppleCalendar"><a href="#import-JTAppleCalendar" class="headerlink" title="import JTAppleCalendar"></a>import JTAppleCalendar</h2><p>아직 코코아팟 안깔렸다면 .. -&gt; <a href="https://jisng.github.io/2020/01/installcocoapods-200105/">Install CocoaPods</a> </p><ol><li>프로젝트 파일로 이동, <code>pod init</code></li><li><code>vi Podfile</code> </li><li>Pod ‘JTAppleCalendar’ (원하시는 분들은 지원 버전까지)</li><li><code>pod install</code></li></ol><p>라이브러리 공식 wiki를 참고하셔도 좋습니다 -&gt; <a href="https://patchthecode.com/jtapplecalendar-home/installation/" target="_blank" rel="noopener">installation</a></p><h2 id="달력-띄우기"><a href="#달력-띄우기" class="headerlink" title="달력 띄우기"></a>달력 띄우기</h2><ol><li><p>DateCell.swift</p><pre><code class="swift">import JTAppleCalendarimport UIKitclass DateCell: JTACDayCell {    let dateLabel = UILabel()  override init(frame: CGRect) {      super.init(frame:frame)    baseUI()  }  required init?(coder aDecoder: NSCoder) {      fatalError(&quot;init(coder:) has not been implemented&quot;)  }  private func baseUI() {      dateLabel.textAlignment = .center    contentView.addSubview(dateLabel)    dateLabel.translatesAutoresizingMaskIntoConstraints = false    dateLabel.centerXAnchor.constraint(equalTo: contentView.centerXAnchor).isActive = true    dateLabel.centerYAnchor.constraint(equalTo: contentView.centerYAnchor).isActive = true    }}</code></pre><p>테이블뷰에서 커스텀셀 만들 듯 만드시면 됩니다.  </p></li></ol><ol start="2"><li><p>MonthViewController.swift</p><pre><code class="swift">import JTAppleCalendarimport UIKitclass MonthViewController: UIViewController {    private let calenderView = JTACMonthView(frame: .zero)  override func viewDidLoad() {      super.viewDidLoad()        addCalender()  }  private func addCalender() {  calenderView.backgroundColor = .white     calenderView.register(DateCell.self, forCellWithReuseIdentifier: &quot;date&quot;)  calenderView.calendarDelegate = self  calenderView.calendarDataSource = self  view.addSubview(calenderView)  calenderView.translatesAutoresizingMaskIntoConstraints = false  calenderView.topAnchor.constraint(equalTo: view.topAnchor).isActive = true  calenderView.leadingAnchor.constraint(equalTo: view.leadingAnchor).isActive = true  calenderView.trailingAnchor.constraint(equalTo: view.trailingAnchor).isActive = true  calenderView.bottomAnchor.constraint(equalTo: view.bottomAnchor).isActive = true  }</code></pre><p>테이블뷰 만드는 거랑 비슷하죠? </p><ul><li>오토레이아웃은 코드가 짧아보이게 적었습니다. 실제 사용할 때는 원하는 위치에 맞춰 적으시면 됩니다.</li><li>캘린더가 이전달-다음달 등 보기 위해서는 CollecitonView 또는 ScrollView위에 올려야 합니다.<br>이 부분은 다음에 다룰 예정입니다. (지금은 무조건 달력만 띄우는 걸로)</li></ul><br><p>이어서…</p><pre><code class="swift">extension MonthViewController: JTACMonthViewDataSource {    func configureCalendar(_ calendar: JTACMonthView) -&gt; ConfigurationParameters {  let formatter = DateFormatter()  formatter.dateFormat = &quot;yyyy MM dd&quot;  let startDate = formatter.date(from: &quot;2020 01 01&quot;)!  let endDate = Date()  return ConfigurationParameters(startDate: startDate, endDate: endDate)  }}extension MonthViewController: JTACMonthViewDelegate {  func calendar(_ calendar: JTACMonthView, cellForItemAt date: Date, cellState: CellState, indexPath: IndexPath) -&gt; JTACDayCell {  let cell = calendar.dequeueReusableJTAppleCell(withReuseIdentifier: &quot;date&quot;, for: indexPath) as! DateCell  cell.dateLabel.text = cellState.text    return cell    }    func calendar(_ calendar: JTACMonthView, willDisplay cell: JTACDayCell, forItemAt date: Date, cellState: CellState, indexPath: IndexPath) {  let cell = cell as! DateCell  cell.dateLabel.text = cellState.text    }}</code></pre><p>보통 테이블뷰 datasource 에서 구현 내용이 여기서는 delegate에서 이루어집니다.</p></li></ol><br><p><img src="/2020/01/jtapplecalendar-programmatically/calender1.png" srcset="undefined" alt="calender1"></p><p>실행해보면, 이런 모양이 나옵니다.</p><h2 id="달력-날짜-구분하기"><a href="#달력-날짜-구분하기" class="headerlink" title="달력 날짜 구분하기"></a>달력 날짜 구분하기</h2><p><img src="/2020/01/jtapplecalendar-programmatically/calender2.png" srcset="undefined" alt="calender2"></p><p>보통 달력들은 이런 모양 혹은, 이번달을 제외한 날짜가 안보이는 모양일 것입니다. 일단 달력 구분부터 해보겠습니다.<br>JTAMonthViewDelegate 에 다음과 같은 함수를 작성합니다. </p><pre><code class="swift">private func configureCell(view: JTACDayCell?, cellState: CellState) {    guard let cell = view as? DateCell  else { return }  cell.dateLabel.text = cellState.text  handleCellTextColor(cell: cell, cellState: cellState)}private func handleCellTextColor(cell: DateCell, cellState: CellState) {    if cellState.dateBelongsTo == .thisMonth {  cell.dateLabel.textColor = UIColor.black  } else {  cell.dateLabel.textColor = UIColor.gray  }}</code></pre><p>앞서 구현한 <code>cellForItemAtDate</code> 함수와 <code>willDisplayCell</code> 의 함수 내용도 다음과 같이 작성합니다. </p><pre><code class="swift">func calendar(_ calendar: JTACMonthView, cellForItemAt date: Date, cellState: CellState, indexPath: IndexPath) -&gt; JTACDayCell {    let cell = calendar.dequeueReusableJTAppleCell(withReuseIdentifier: &quot;date&quot;, for: indexPath) as! DateCell  self.calendar(calendar, willDisplay: cell, forItemAt: date, cellState: cellState, indexPath: indexPath)  return cell}func calendar(_ calendar: JTACMonthView, willDisplay cell: JTACDayCell, forItemAt date: Date, cellState: CellState, indexPath: IndexPath) {    configureCell(view: cell, cellState: cellState)}</code></pre><br><p>실행해보면 원하던 모양이 나옵니다.<br>그럼 이제 숨겨보겠습니다.</p><pre><code class="swift">private func handleCellTextColor(cell: DateCell, cellState: CellState) {    if cellState.dateBelongsTo == .thisMonth {        cell.isHidden = false    } else {        cell.isHidden = true  }}</code></pre><p><code>handleCellTextColor</code> 부분을 이렇게 바꾼 후 실행해보면, 다음과 같이 나옵니다. </p><p><img src="/2020/01/jtapplecalendar-programmatically/calender3.png" srcset="undefined" alt="calender3"></p><p>짠!</p>]]></content>
    
    
    <categories>
      
      <category>TIL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>JTAppleCalendar</tag>
      
      <tag>Library</tag>
      
      <tag>Calender</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Install CocoaPods</title>
    <link href="undefined2020/01/installcocoapods-200105/"/>
    <url>2020/01/installcocoapods-200105/</url>
    
    <content type="html"><![CDATA[<h1 id="How-to-install-CocoaPods"><a href="#How-to-install-CocoaPods" class="headerlink" title="How to install CocoaPods?"></a>How to install CocoaPods?</h1><h2 id="What-is-CocoaPods"><a href="#What-is-CocoaPods" class="headerlink" title="What is CocoaPods?"></a>What is CocoaPods?</h2><p>오픈소스 라이브러리를 사용하기 위한 도구입니다.</p><ul><li>라이브러리 추가, 삭제, 업데이트 등의 관리</li><li>라이브러리 버전을 직접 지정할 수 있어, 라이브러리 강제 업데이트를 당하지(?) 않고 계속 사용할 수 있다.</li></ul><h2 id="How-to-use-CocoaPods"><a href="#How-to-use-CocoaPods" class="headerlink" title="How to use CocoaPods?"></a>How to use CocoaPods?</h2><ol><li><p>터미널 -&gt; <code>sudo gem install cocoapods</code></p><img src="/2020/01/installcocoapods-200105/img1.png" srcset="undefined" alt="img1" style="zoom:50%;"></li><li><p>(선택사항) <code>pod setup --verbose</code></p><img src="/2020/01/installcocoapods-200105/img2.png" srcset="undefined" alt="img2" style="zoom:50%;"></li><li><p>라이브러리를 사용 할 프로젝트 파일로 이동, <code>pod init</code></p><img src="/2020/01/installcocoapods-200105/img3.png" srcset="undefined" alt="img3" style="zoom:50%;"></li><li><p>생성 된 Podfile 열기, <code>vi Podfile</code></p><img src="/2020/01/installcocoapods-200105/img4.png" srcset="undefined" alt="img4" style="zoom:50%;"></li><li><p>사용 할 라이브러리 적기, <code>pod Snapkit, ~&gt;5.0</code></p><p> 버전은 cocoapods 사이트에서 사용 라이브러리를 검색, 버전을 선택하세요.</p><img src="/2020/01/installcocoapods-200105/img5.png" srcset="undefined" alt="img5" style="zoom:50%;"></li><li><p><code>pod install -verbose</code></p><img src="/2020/01/installcocoapods-200105/img6.png" srcset="undefined" alt="img6" style="zoom:50%;"></li><li><p>생성된 xcworkspace로 들어가서 <code>import Snapkit</code></p><ol><li><img src="/2020/01/installcocoapods-200105/img7.png" srcset="undefined" alt="img7" style="zoom:50%;"></li><li><img src="/2020/01/installcocoapods-200105/img8.png" srcset="undefined" alt="img8" style="zoom:50%;"></li><li><img src="/2020/01/installcocoapods-200105/img9.png" srcset="undefined" alt="img9" style="zoom:50%;"></li></ol></li></ol><h2 id="How-to-delete-library"><a href="#How-to-delete-library" class="headerlink" title="How to delete library?"></a>How to delete library?</h2><ol><li>Podfile 에서 작성한 library 부분을 지웁니다.</li><li><code>pod install</code></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>TIL</tag>
      
      <tag>CocoaPods</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Xcode Font</title>
    <link href="undefined2020/01/200104-xcode-font/"/>
    <url>2020/01/200104-xcode-font/</url>
    
    <content type="html"><![CDATA[<h1 id="Xcode-폰트-추가하기"><a href="#Xcode-폰트-추가하기" class="headerlink" title="Xcode 폰트 추가하기"></a>Xcode 폰트 추가하기</h1><ol><li>폰트 otf 파일 받기<img src="/2020/01/200104-xcode-font/downloadOTF.png" srcset="undefined" alt="downloadOTF" style="zoom:50%;"></li><li>Xcode 프로젝트 리소스에 파일 넣기<img src="/2020/01/200104-xcode-font/inputOTF.png" srcset="undefined" alt="inputOTF" style="zoom:50%;"></li><li>폰트 파일을 사용할 수 있도록 Info.plist 파일에 추가하기<img src="/2020/01/200104-xcode-font/setInfoplist.png" srcset="undefined" alt="setInfoplist" style="zoom:50%;"><img src="/2020/01/200104-xcode-font/info1.png" srcset="undefined" alt="info1" style="zoom:50%;"><img src="/2020/01/200104-xcode-font/info2.png" srcset="undefined" alt="info2" style="zoom:50%;"></li><li>코드에서 사용법<img src="/2020/01/200104-xcode-font/useCode.png" srcset="undefined" alt="useCode" style="zoom:50%;"></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>xcode</tag>
      
      <tag>iOS</tag>
      
      <tag>TIL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>View 와 Controller</title>
    <link href="undefined2019/12/view-controller-til-191211/"/>
    <url>2019/12/view-controller-til-191211/</url>
    
    <content type="html"><![CDATA[<h1 id="View-Controller"><a href="#View-Controller" class="headerlink" title="View + Controller"></a>View + Controller</h1><p>오늘 조교님이 준비해주신 실습을 통해 그동안 합쳐서 써오던 ViewController를 View와 Controller로 떼어서 쓸 수 있게 되었습니다!<br>이제 MVC 패턴을 쓸 수 있게 되었어요 :) (그동안 Model + ViewController로 썼음)<br>이렇게 나누었을 때, View를 어떻게 구성해야 재사용이 가능한지도 배웠으니<br>배우고 익힌 내용을 한 번 담아보겠습니다. (땡쓰업쓰!) </p><h2 id="1-폴더링하기"><a href="#1-폴더링하기" class="headerlink" title="1. 폴더링하기"></a>1. 폴더링하기</h2><p>폴더 만드는 단축키 <code>cmd + option + n</code>    </p><p>저는 다음과 같이 폴더링했습니다.</p><ul><li>View<ul><li>BaseUI</li></ul></li><li>Controller<ul><li>FirstViewController</li></ul></li></ul><h2 id="2-View-만들기-BaseUI-swift"><a href="#2-View-만들기-BaseUI-swift" class="headerlink" title="2. View 만들기(BaseUI.swift)"></a>2. View 만들기(BaseUI.swift)</h2><pre><code class="swift">import UIKitclass BaseUI: UIView {    private let titleLabel = UILabel()    private let textField = UITextField()    private let lineForTextField = UILabel()    private let button = UIButton()    override init(frame: CGRect) {        super.init(frame: frame)        drawUI()    }    // 스토리보드, xib 개입을 대비하여 기본적으로 작성합니다.    required init?(coder: NSCoder) {        fatalError(&quot;init(coder:) has not been implemented&quot;)    }    private func drawUI() {        titleLabel.frame = CGRect(x: 0, y: 0, width: self.bounds.width - 30, height: 100)        titleLabel.center = CGPoint(x: self.bounds.width / 2, y: 100)        titleLabel.textColor = UIColor(ciColor: .black)        titleLabel.font = UIFont.systemFont(ofSize: 30, weight: .heavy)        self.addSubview(titleLabel)        textField.frame = CGRect(x: 0, y: 0, width: self.bounds.width - 30, height: 30)        textField.center = CGPoint(x: self.bounds.width / 2, y: titleLabel.frame.maxY + 50)        textField.borderStyle = .none        self.addSubview(textField)        lineForTextField.frame = CGRect(x: 0, y: 0, width: textField.frame.width - 5, height: 2)        lineForTextField.center = CGPoint(x: self.bounds.width / 2, y: textField.frame.maxY + 10)        lineForTextField.text = &quot;&quot;        lineForTextField.backgroundColor = .gray        self.addSubview(lineForTextField)        button.frame = CGRect(x: 0, y: 0, width: 300, height: 50)        button.center = CGPoint(x: self.bounds.width / 2, y: textField.frame.maxY + 100)        button.setTitle(&quot;NEXT&quot;, for: .normal)        button.backgroundColor = .black        button.setTitleColor(.white, for: .normal)        button.layer.cornerRadius = 16        button.addTarget(self, action: #selector(actionButton(_:)), for: .touchUpInside)        self.addSubview(button)    }    @objc func actionButton(_ sender: UIButton) {        // 버튼은 장식    }}</code></pre><h2 id="3-Controller에서-띄우기-ViewController-swift"><a href="#3-Controller에서-띄우기-ViewController-swift" class="headerlink" title="3. Controller에서 띄우기 (ViewController.swift)"></a>3. Controller에서 띄우기 (ViewController.swift)</h2><pre><code class="swift">import UIKitclass ViewController: UIViewController {    override func viewDidLoad() {        super.viewDidLoad()        let custom = BaseUI(frame: view.frame)        view.addSubview(custom)    }}extension ViewController: UITextFieldDelegate {    func textFieldShouldReturn(_ textField: UITextField) -&gt; Bool {        textField.resignFirstResponder()        return true    }}</code></pre><h2 id="4-자주-실수하는-부분-체크하기"><a href="#4-자주-실수하는-부분-체크하기" class="headerlink" title="4. 자주 실수하는 부분 체크하기"></a>4. 자주 실수하는 부분 체크하기</h2><pre><code class="swift">// UIViewoverride init(frame: CGRect) {        super.init(frame: frame)        drawUI()    }</code></pre><p>아직은 이니셜라이즈를 커스텀해서 사용하지 않을 거라서 override해서 사용할거에요.<br>override를 한다는 것은? 이미 부모클래스에서 구현이 되어 있다는 뜻!</p><pre><code class="swift">// ViewControlleroverride func viewDidLoad() {        super.viewDidLoad()        let custom = BaseUI(frame: view.frame)        view.addSubview(custom)    }</code></pre><p>UIView의 초기화 구문을 사용해야 하는데, 이 때 frame 값을 <code>view.frame</code>으로 적어줘야 화면에 사이즈가 딱 잡혀서 나옵니다 :) </p><h2 id="5-재사용-할-수-있는-View로-만들기-BaseUI-swift"><a href="#5-재사용-할-수-있는-View로-만들기-BaseUI-swift" class="headerlink" title="5. 재사용 할 수 있는 View로 만들기 (BaseUI.swift)"></a>5. 재사용 할 수 있는 View로 만들기 (BaseUI.swift)</h2><p>뷰컨트롤러가 10개쯤 있다고 가정해볼게요.<br>방금 만들어놓은 뷰를 가져다 쓸껀데 각 뷰컨의 제목은 모두 다르게 즉, <code>titleLabel.text</code> 를 뷰컨마다 다르게 작성하고 싶다면?<br>3가지 방법이 있습니다! </p><ol><li>초기화 구문을 커스텀해서 사용하기</li><li>함수 만들어서 사용하기</li><li>델리게이트 사용하기</li></ol><p>개인적으로 쉽다고 생각한 순서대로 적었으니, 하나씩 코드로 구현해볼게요.</p><h3 id="1-초기화-구문-커스텀"><a href="#1-초기화-구문-커스텀" class="headerlink" title="1. 초기화 구문 커스텀"></a>1. 초기화 구문 커스텀</h3><pre><code class="swift">// UIViewinit(frame: CGRect, title: String) {        super.init(frame: frame)        titleLabel.text = title        drawUI()    }</code></pre><p>기존의 오버라이드 초기화 구문을 지우고, 위와 같이 작성합니다.</p><pre><code class="swift">// ViewControlleroverride func viewDidLoad() {        super.viewDidLoad()        let custom = BaseUI(frame: view.frame, title: &quot;첫번째 화면에 오셨네요!&quot;)        view.addSubview(custom)    }</code></pre><p>이렇게 하면 각 뷰컨트롤러마다 View를 가져다 쓸 때마다 손쉽게 바꿀 수 있습니다 ! 진짜 간단 !</p><h3 id="2-함수-사용"><a href="#2-함수-사용" class="headerlink" title="2. 함수 사용"></a>2. 함수 사용</h3><pre><code class="swift">// UIViewfunc customUI(_ label: String) {        titleLabel.text = label    }</code></pre><pre><code class="swift">// ViewControlleroverride func viewDidLoad() {        super.viewDidLoad()        let custom = BaseUI(frame: view.frame, title: &quot;첫번째 화면에 오셨네요!&quot;)        custom.customUI(&quot;hi?&quot;)        view.addSubview(custom)    }</code></pre><p>처음에 가정한 것처럼 뷰컨트롤러들의 <code>textLabel.text</code> 만 바꾸는 거라면, 첫 번째 방법이 간편할 것이고<br>텍스트필드나 버튼의 텍스트들 등 여러개를 바꾼다면 함수를 사용하는 것이 좀 더 깔끔할 것 같아요. </p><h3 id="3-델리게이트-사용"><a href="#3-델리게이트-사용" class="headerlink" title="3. 델리게이트 사용 (?)"></a>3. 델리게이트 사용 (?)</h3><p>아시다시피 델리게이트를 사용하려면 몇 가지 작업들을 해야합니다…</p><pre><code class="swift">// BaseUI.swiftprotocol BaseUIDelegate: class {    func storage() -&gt; String}</code></pre><pre><code class="swift">// BaseUIweak var delegate: BaseUIDelegate?</code></pre><pre><code class="swift">// drawUI()titleLabel.text = delegate?.storage()</code></pre><p>View 그리는 곳에서 델리게이트 선언을 합니다.</p><pre><code class="swift">// ViewControlleroverride func viewDidLoad() {        super.viewDidLoad()        let custom = BaseUI(frame: view.frame, title: &quot;첫번째 화면에 오셨네요!&quot;)        custom.delegate = self        view.addSubview(custom)    }</code></pre><pre><code class="swift">extension ViewController: StorageDelegate {    func storage() -&gt; String {        &quot;델리게이트 사용!&quot;    }}</code></pre><p>Controller 에서 델리게이트 구현하고 실행해보면,<br>… <strong>안돼요.</strong>  </p><br><p>컴퓨터가 코드를 읽는 순서 : </p><ol><li>VC <code>viewDidLoad()</code>  -&gt; 초기화 시작</li><li>BaseUI 읽으면서 UI 그리는 중…</li><li><code>titleLabel.text = delegate?.storage()</code> 만남 </li><li>delegate 메서드를 구현 할 객체를 찾으러 떠남…</li><li>.. 없음!!  찾을 수 없음..!</li></ol><br><p><code>custom.delegate = self</code> 코드는 초기화가 끝난 다음에 읽을 수 있기 때문에, 상상하던대로 구현되지 않습니다. </p><h3 id="4-어떻게든-델리게이트-사용"><a href="#4-어떻게든-델리게이트-사용" class="headerlink" title="4. 어떻게든 델리게이트 사용"></a>4. 어떻게든 델리게이트 사용</h3><pre><code class="swift">// BaseUI.swiftprotocol BaseUIDelegate: class {    func storage() -&gt; String      func force() -&gt; String}</code></pre><pre><code class="swift">// BaseUIfunc forceFunc() {      titleLabel.text = delegate?.force()    }</code></pre><p>프로토콜 메서드를 추가합니다.  그리고 BaseUI에서 델리게이트 메서드를 실행 할 메서드를 작성합니다.</p><pre><code class="swift">// View Controllerextension ViewController: BaseUIDelegate {    func force() -&gt; String {        &quot;델리게이트 진짜 진짜 사용!&quot;    }    func storage() -&gt; String { &quot;델리게이트 사용!&quot; }}</code></pre><pre><code class="swift">// ViewControllerprivate func customUI() {      let custom = BaseUI(frame: view.frame, title: &quot;&quot;)      custom.delegate = self      custom.forceFunc()      view.addSubview(customView)    }</code></pre><pre><code class="swift">override func viewDidLoad() {        super.viewDidLoad()//        let custom = BaseUI(frame: view.frame, title: &quot;첫번째 화면에 오셨네요!&quot;)//        custom.delegate = self//        view.addSubview(custom)        customUI()    }</code></pre><p>Controller 부분에서는 프로토콜의 메서드들을 구현한 뒤, UI를 만들어주는 메서드를 작성합니다.<br>이전에 <code>viewDidLoad()</code> 에 작성해주었던 코드를 그대로 옮겨왔고, View에서 새로 만든 메서드 <code>forceFun()</code> 를 추가해주세요.<br>마지막으로 <code>viewDidLoad()</code> 의 기존 코드들은 주석처리하고, UI를 만들어주는 <code>customUI()</code> 를 작성해주세요.<br>그럼 이제 잘 나오는걸 확인할 수 있습니다. </p><br><p>이렇게 어떻게든(?) 델리게이트로 구현해보았는데,<br> “델리게이트로 할 수는 있다” 정도로만 알아두면 좋을 것 같습니다 :) </p>]]></content>
    
    
    <categories>
      
      <category>TIL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Struct</title>
    <link href="undefined2019/12/struct-til-191209/"/>
    <url>2019/12/struct-til-191209/</url>
    
    <content type="html"><![CDATA[<h1 id="Struct"><a href="#Struct" class="headerlink" title="Struct"></a>Struct</h1><h2 id="Comparing-Structures-and-Classes"><a href="#Comparing-Structures-and-Classes" class="headerlink" title="Comparing Structures and Classes"></a>Comparing Structures and Classes</h2><h3 id="클래스와-구조체-공통점"><a href="#클래스와-구조체-공통점" class="headerlink" title="클래스와 구조체 공통점"></a>클래스와 구조체 공통점</h3><ul><li><p>값을 저장하기 위한 프로퍼티</p></li><li><p>기능을 제공하기 위한 메서드</p></li><li><p>초기 상태를 설정하기 위한 생성자</p></li><li><p>기본 구현에서 기능을 추가하기 위한 확장(Extension)</p></li><li><p>특정 값에 접근할 수 있는 첨자(Subscript)</p></li><li><p>특정한 기능을 수행하기 위한 프로토콜 채택</p></li><li><p>Upper Camel Case 사용</p></li></ul><h4 id="클래스만-제공하는-기능"><a href="#클래스만-제공하는-기능" class="headerlink" title="클래스만 제공하는 기능"></a>클래스만 제공하는 기능</h4><ul><li><p>상속 (Inheritance)</p></li><li><p>소멸자 (Deinitializer) -  deinit 메서드</p></li><li><p>참조 카운트 (Reference counting)</p></li></ul><h3 id="값-타입-Vs-참조-타입"><a href="#값-타입-Vs-참조-타입" class="headerlink" title="값 타입 Vs 참조 타입"></a>값 타입 Vs 참조 타입</h3><pre><code class="swift">class Dog {  var name = &quot;똘똘이&quot;}struct Cat {  var name = &quot;애옹이&quot;}let dog = Dog()let cat = Cat()dog.name = &quot;똘똘이2&quot; // 가능cat.name = &quot;애옹이2&quot; // 에러 : Stack, 값참조, 접근 불가let cat1 = catcat === cat1 // 사용불가, 값타입으로 해당 연산자 사용 불가</code></pre><h3 id="생성자-비교"><a href="#생성자-비교" class="headerlink" title="생성자 비교"></a>생성자 비교</h3><table><thead><tr><th></th><th>구조체</th><th>클래스</th></tr></thead><tbody><tr><td>초기화</td><td>필수</td><td>자동 생성</td></tr><tr><td>일부만 초기화</td><td>나머지 필수 초기화</td><td>나머지 자동 초기화</td></tr><tr><td>편의 생성자</td><td>사용 가능</td><td>지정 생성자와 <br>별도 구분 없이 사용</td></tr></tbody></table><h3 id="프로퍼티-변경"><a href="#프로퍼티-변경" class="headerlink" title="프로퍼티 변경"></a>프로퍼티 변경</h3><pre><code class="swift">struct PointStruct {  var x = 0 mutating func updateX() {  // 값 타입은 mutating 붙여줘야 한다 / enum, struct    self.x = 5  }  var updateProperty: Int {  // 연산프로퍼티는 사용 안해도 된다    get { x }    set { x = newValue }    // 연산 프로퍼티의 setter는 기본적으로 mutating  }}let p2 = PointStruct()p2.updateX() // error : constantp2.updateProperty = 3 // error : constantp2.updateProperty // 0var p3 = PointStruct()p3.updateX() // p3.x // 5p3.updateProperty = 3p3.updateProperty // 3</code></pre><h3 id="프로토콜-적용"><a href="#프로토콜-적용" class="headerlink" title="프로토콜 적용"></a>프로토콜 적용</h3><pre><code class="swift">protocol Mutate {  mutating func update() // struct 에서 mutating 을 사용하고 싶으면, 프로토콜에서부터 ...}struct PointStruct1: Mutate {  var x = 0  mutating func update() {    self.x = 5  }}</code></pre><hr><h1 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h1><h2 id="Memory-Management"><a href="#Memory-Management" class="headerlink" title="Memory Management"></a>Memory Management</h2><p>다른 언어에서는 다음과 같은 방식들로 메모리 관리를 한다.</p><ul><li>GC(Garbage Collection)</li><li>MRR(Manual Retain-Release) / MRC(Manual Reference Counting)</li></ul><p>메모리 문제</p><ul><li>Memory Leak : 더 이상 사용하지 않는 메모리들이 많음</li><li>Dangling Pointer : 찾아야 하는데 찾을 수 없는 허상 메모리들이 생김</li></ul><h2 id="ARC-Automatic-Reference-Counting"><a href="#ARC-Automatic-Reference-Counting" class="headerlink" title="ARC - Automatic Reference Counting"></a>ARC - Automatic Reference Counting</h2><ul><li>컴파일러가 개발자를 대신하여 메모리 관리 코드를 적절한 위치에 자동으로 삽입</li><li>컴파일 단에서 처리 (Heap 에 대한 스캔 불필요 / 앱 일시 정시 현상 없음)</li><li>메모리 관리 이슈를 줄이고 개발자가 코딩 자체에 집중할 수 있도록 함</li></ul><h3 id="적용"><a href="#적용" class="headerlink" title="적용"></a>적용</h3><ul><li><p>ARC는 클래스의 인스턴스에만 적용 (Class - Reference타입, Struct / Enum - Value 타입)</p></li><li><p>활성화된 참조카운트가 하나라도 있을 경우 메모리에서 해제 되지 않는다.</p></li></ul><ul><li>참조 타입<ul><li>강한 참조 (Strong): 기본값, 참조될 때마다 참조 카운트 1 증가</li><li>약한 참조 (Weak), 미소유 참조(Unowned): 참조 카운트를 증가시키지 않음</li><li><strong>주의 !!</strong> 강한 순환 참조 (Strong Reference Cycles) </li></ul></li></ul><table><thead><tr><th></th><th align="center">var</th><th align="center">let</th><th align="center">Optional</th><th align="center">Non-Optional</th></tr></thead><tbody><tr><td>strong</td><td align="center">⭕️</td><td align="center">⭕️</td><td align="center">⭕️</td><td align="center">⭕️</td></tr><tr><td>weak</td><td align="center">⭕️</td><td align="center">❌</td><td align="center">⭕️</td><td align="center">❌</td></tr><tr><td>unowned</td><td align="center">⭕️</td><td align="center">⭕️</td><td align="center">❌</td><td align="center">⭕️</td></tr></tbody></table><h4 id="ARC-in-Class"><a href="#ARC-in-Class" class="headerlink" title="ARC in Class"></a>ARC in Class</h4><p><video src="struct-til-191209/classReferenceCounting.mov"></video></p><h4 id="ARC-in-Struct"><a href="#ARC-in-Struct" class="headerlink" title="ARC in Struct"></a>ARC in Struct</h4><p><video src="struct-til-191209/structReferenceCounting.mov"></video></p><h4 id="Strong-Reference-Cycle"><a href="#Strong-Reference-Cycle" class="headerlink" title="Strong Reference Cycle"></a>Strong Reference Cycle</h4><ul><li>객체에 접근 가능한 모든 연결을 끊었음에도 순환 참조로 인해 활성화된 참조 카운트가 남아 있어 메모리 누수가 발생</li><li>앱의 실행이 느려지거나 오동작 또는 오류를 발생시키는 원인</li></ul><p><video src="struct-til-191209/StrongReference.mov"></video></p><h4 id="Weak-Reference"><a href="#Weak-Reference" class="headerlink" title="Weak Reference"></a>Weak Reference</h4><p><video src="struct-til-191209/WeakReference.mov"></video></p><h4 id="strong-vs-weak-vs-unowned"><a href="#strong-vs-weak-vs-unowned" class="headerlink" title="strong vs. weak vs. unowned"></a>strong vs. weak vs. unowned</h4><table><thead><tr><th></th><th>strong</th><th>weak</th><th>unowned</th></tr></thead><tbody><tr><td>-</td><td>기본값</td><td></td><td></td></tr><tr><td>참조</td><td>강한 참조</td><td>약한 참조</td><td>미소유 참조</td></tr><tr><td>Count</td><td>Reference Count + 1</td><td>참조하던 객체 해제 시 <br>nil값으로 변경</td><td>참조 객체 해제 시에도 <br>기존 포인터 주소 유지</td></tr><tr><td>nil</td><td>명시적으로 대입</td><td>자동 deinit <br>nil 처리 된 속성에 접근하면 nil 반환</td><td>자동 deinit <br> nil 처리 된 속성에 접근하면 nil 반환</td></tr></tbody></table><pre><code class="swift">class Person {  let testCase: String  init(testCase: String) {    self.testCase = testCase  }  deinit {    print(&quot;\(testCase) is being deinitialized&quot;)  }}var strongObj4 = Person(testCase: &quot;case4&quot;)print(strongObj4)weak var weakObj4 = Person(testCase: &quot;case4&quot;)print(weakObj4)unowned var unownedObj4 = Person(testCase: &quot;case4&quot;) // count 0 -&gt; unowned (카운터 증가시키지 않음) =&gt; 사라짐print(unownedObj4) // 사라진 주소값에 접근하므로 오류</code></pre><h2 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h2><pre><code class="swift">class LocalScope {  func doSomething() {}  deinit {    print(&quot;LocalScope is being deinitialized&quot;)  }}class ClassProperty {  func doSomething() {}  deinit {    print(&quot;ClassProperty is being deinitialized&quot;)  }}class Application {  var prop = ClassProperty()  func allocateInstance() {    let local = LocalScope()    local.doSomething()  }  deinit {    print(&quot;Application is being deinitialized&quot;)  }}// Q. 아래의 코드 실행 시 출력되는 메시지는?var app: Application? = Application()app?.prop.doSomething()app?.allocateInstance() // &quot;LocalScope is being deinitialized&quot;// Q. ClassProperty 객체의 deinit 메서드가 호출되려면 어떻게 할까요?app = nil</code></pre><h2 id="Strong-Reference-Cycles"><a href="#Strong-Reference-Cycles" class="headerlink" title="Strong Reference Cycles"></a>Strong Reference Cycles</h2><pre><code class="swift">// 강한순환참조발생class Person {  var pet: Dog?  func doSomething() {}  deinit {    print(&quot;Person is being deinitialized&quot;)  }}class Dog {  var owner: Person?  func doSomething() {}  deinit {    print(&quot;Dog is being deinitialized&quot;)  }}var me: Person? = Person() // count 1var viva: Dog? = Dog() // count 1me?.pet = viva // count2viva?.owner = me // count2me?.doSomething()viva?.doSomething()//me = nil // person count = 1//viva = nil // person count = 1// 메모리 누수// 순서 주의me?.pet = nilviva?.owner = nilme = nilviva = nil</code></pre>]]></content>
    
    
    <categories>
      
      <category>TIL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>swift</tag>
      
      <tag>sturct</tag>
      
      <tag>ARC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Segue-TIL-191203</title>
    <link href="undefined2019/12/segue-til-191203/"/>
    <url>2019/12/segue-til-191203/</url>
    
    <content type="html"><![CDATA[<h1 id="Segue-Action-Segue"><a href="#Segue-Action-Segue" class="headerlink" title="Segue : Action Segue"></a>Segue : Action Segue</h1><ol><li>(Storyboard)First &lt;-&gt; (Class)FirstVC</li><li>(Storyboard)Second &lt;-&gt; (Class)SecondVC</li><li>각 스토리보드에 버튼 생성</li></ol><br><h2 id="Present-Modally"><a href="#Present-Modally" class="headerlink" title="Present Modally"></a>Present Modally</h2><ol><li>(Storyboard)First : 버튼 선택, control 누른 상태에서, (Storyboard)Second로 연결 “Present Modally”</li></ol><img src="/2019/12/segue-til-191203/segue.png" srcset="undefined" alt="segue" style="zoom:50%;"><br><h2 id="Unwind"><a href="#Unwind" class="headerlink" title="Unwind"></a>Unwind</h2><ol><li>(Class)FirstVC 에 unwind 작성</li></ol><img src="/2019/12/segue-til-191203/un.png" srcset="undefined" alt="un" style="zoom:50%;"><img src="/2019/12/segue-til-191203/unwind.png" srcset="undefined" alt="unwind" style="zoom:50%;"><ol start="2"><li>(Storyboard)SecondVC 버튼에서 unwind 연결</li></ol><img src="/2019/12/segue-til-191203/exit1.png" srcset="undefined" alt="exit1" style="zoom:50%;"><br><ol start="3"><li><p>Segue 에서 자주 쓰는 함수  </p><ol><li><code>shouldPerformSegue~</code> : 화면을 전환하기 전 “어떤 조건”을 확인하여, 화면 전환 여부를 결정하는 함수</li><li><code>prepare</code> : 화면을 전환하면서, 다음 화면의 저장 프로퍼티를 컨트롤 할 수 있는 함수</li><li><code>unwind~</code> : 전환한 화면을 내리면서 현재 화면으로 돌아올 때, 프로퍼티들을 컨트롤 할 함수</li></ol></li></ol><pre><code class="swift">   override func shouldPerformSegue(withIdentifier identifier: String, sender: Any?) -&gt; Bool {           super.shouldPerformSegue(withIdentifier: identifier, sender: sender)           var temp = 0           // count 값이 50이 넘어가면 화면전환 불가           if identifier == &quot;Plus1&quot; {               temp = count + 1           } else {               temp = count + 40           }           if temp &gt; 50 {               return false           } else {               count = temp               return true           }           // count 값이 50이전이면 화면전환 가능       }   override func prepare(for segue: UIStoryboardSegue, sender: Any?) {           super.prepare(for: segue, sender: sender) // super 역할을 할 수도 있고 , 안할 수도 있지만, 하나하나 확인하고 쓸지 말지 결정하기 보다 무조건 씁니다.           guard let secondVC = segue.destination as? SecondViewController else { return }           if segue.identifier == &quot;Plus1&quot; {               //            count += 1               secondVC.count = count           } else if segue.identifier == &quot;Plus40&quot; {               //            count += 40               secondVC.count = count           }           else if segue.identifier == &quot;Card&quot; {               secondVC.secondLabel.text = &quot;Card&quot;           } else {               secondVC.secondLabel.text = &quot;FullScreen&quot;           }       }   @IBAction func unwindToFirstVC(_ unwindSegue: UIStoryboardSegue) {           let sourceViewController = unwindSegue.source // secondVC           guard let secondVC = sourceViewController as? SecondViewController else { return }   //        guard let secondVC = unwindSegue.source as? SecondViewController else { return }           self.count -= secondVC.tftext           print(count, secondVC.tftext)           firstCount.text = &quot;\(count)&quot;       }</code></pre>   <img src="/2019/12/segue-til-191203/segueFunc.png" srcset="undefined" alt="segueFunc" style="zoom:50%;"><br><h1 id="Segue-Manual-Segue"><a href="#Segue-Manual-Segue" class="headerlink" title="Segue: Manual Segue"></a>Segue: Manual Segue</h1><p>위에서 한 액션 세그웨이는 특정 버튼으로 연결시켰지만, 메뉴얼 세그웨이는 특정 버튼(액션)과 연결되지 않습니다.<br>필요할 때 메뉴얼 세그웨이의 identifier 값을 이용하여 연결시켜서 작동합니다.  </p><br><p>제가 메뉴얼 세그웨이를 사용한 코드를 올릴게요.<br>저는 첫번째 화면에서 액션 세그웨이를 통해 화면을 전환 시켰고,<br>unwind 함수에서 실행할 내용을,<br>두번째 화면 버튼의 작동 여부에 따라 실행시키기 위해 두번째 화면에서 메뉴얼 세그웨이를 사용하였습니다. </p><br><pre><code class="swift">func alert() {        let alert = UIAlertController(title: &quot;주문 확인&quot;, message: &quot;주문 받았습니다&quot;, preferredStyle: .alert)        let ok = UIAlertAction(title: &quot;주문&quot;, style: .default) { _ in            self.performSegue(withIdentifier: &quot;ManualUnwind&quot;, sender: nil)        }        let cancle = UIAlertAction(title: &quot;취소&quot;, style: .cancel, handler: nil)        alert.addAction(ok)        alert.addAction(cancle)        present(alert, animated: true)    }</code></pre><br><p>버튼에 얼럿 함수를 연결, 얼럿 확인 버튼을 눌렀을 때 첫번째 화면으로 전환하는 기능입니다.<br><code>self.performSegue(withIdentifier: &quot;ManualUnwind&quot;, sender: nil)</code><br>“ManualUnwind” 는 메뉴얼 세그웨이의 identifier 입니다.</p><br><p>해당 내용에 대한 자세한 설명은 링크로 대체할게요 ㅠ.. <a href="https://stackoverflow.com/questions/12509422/how-to-perform-unwind-segue-programmatically" target="_blank" rel="noopener">HowToPerfromSegueProgrammatically?</a></p>]]></content>
    
    
    <categories>
      
      <category>TIL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>segue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FirstExamReview2-TIL-191201</title>
    <link href="undefined2019/12/til-191201/"/>
    <url>2019/12/til-191201/</url>
    
    <content type="html"><![CDATA[<h1 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h1>]]></content>
    
    
    <categories>
      
      <category>TIL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FirstExamReview1-TIL-191129</title>
    <link href="undefined2019/11/FirstExamReview-TIL-191129/"/>
    <url>2019/11/FirstExamReview-TIL-191129/</url>
    
    <content type="html"><![CDATA[<h1 id="1차-시험"><a href="#1차-시험" class="headerlink" title="1차 시험"></a>1차 시험</h1><p>오전 시험은 이론과 기초 문법으로 문제 풀기였는데,<br>일단 문제푸는 건 하나도 제대로 동작시키지 못했기 때문에 모든 문제를 다시 풀어보고(ㅠㅠ)<br>이론 문제는 다 쓰긴 했지만, 설명하기가 어려워 부족한 답을 썼던 부분을 복습합니다.<br>오후 시험은 기능 구현하기였는데, 구현은 했으나 더 좋은 코드를 향해 수정을 해봅니다 ..</p><br><h2 id="오전-이론"><a href="#오전-이론" class="headerlink" title="오전 - 이론"></a>오전 - 이론</h2><blockquote><p>확실히 틀린 부분. AppLifeCycle… </p></blockquote><h2 id="AppLifeCycle"><a href="#AppLifeCycle" class="headerlink" title="AppLifeCycle :"></a>AppLifeCycle :</h2><ul><li>Not Running: 실행되지 않았거나, 시스템에 의해 종료된 상태.</li><li>Inactive: 실행중이지만 이벤트를 받고 있지 않은 상태. </li><li>Active: 어플리케이션이 실질적인 활동을 하고 있는 상태.</li><li>Background: 백그라운드 상태에서 동작하고 있는 상태.</li><li>Suspended: 백그라운드 상태에서 활동을 멈춘 상태.</li></ul><br><ul><li><code>application:willFinishLaunchingWithOptions:</code><br>어플리케이션이 최초 실행될 때 호출되는 메소드</li><li><code>application:didFinishLaunchingWithOptions:</code><br>어플리케이션이 실행된 직후 사용자의 화면에 보여지기 직전에 호출</li><li><code>applicationDidBecomeActive:</code><br>어플리케이션이 Active 상태로 전환된 직후 호출</li><li><code>applicationWillResignActive:</code><br>어플리케이션이 Inactive 상태로 전환되기 직전 호출</li><li><code>applicationDidEnterBackground:</code><br>어플리케이션이 백그라운드 상태로 전환된 직후 호출</li><li><code>applicationWillEnterForeground:</code><br>어플리케이션이 Active 상태가 되기 직전에, 화면에 보여지기 직전의 시점에 호출</li><li><code>applicationWillTerminate:</code><br>어플리케이션이 종료되기 직전에 호출</li></ul><hr><h2 id="오전-실습"><a href="#오전-실습" class="headerlink" title="오전 - 실습"></a>오전 - 실습</h2><p>&lt;1.&gt;.  다음의 클로져를 FullSyntax 로부터 Optimized Syntax 로 차근차근 줄여보세요. 그리고 그 과정에 일어나는 변화를 주석으로 설명하세요.</p><pre><code class="swift"></code></pre><br><p>&lt;2.&gt; 자연수 하나를 입력받아 1년부터 그 해까지의 모든 윤년의 개수를 출력하는 함수</p><pre><code class="swift">/* (공식 : 매 4년 마다 윤년. 매 100년 째에는 윤년이 아님. 매 400년 째에는 윤년) 윤년O 예시 - 160, 204, 400, 1996, 2000, 2800 윤년X 예시 - 200, 300, 500, 600, 1900, 2100 Intput : 2019 Output : 윤년에 속하는 해는 총 489회입니다.*/func 윤년(num: Int) -&gt; Int {    // num % 4 == 0 // +    // num % 100 == 0 // -    // num % 400 == 0 // +    var result = 0    for num in 1...num {        if num % 4 == 0 {            result += 1        }        if num % 100 == 0 {            result -= 1            if num % 400 == 0 {                result += 1            }        }    }    return result}윤년(num: 2019)</code></pre><br><p>&lt;3.&gt; 주어진 문자 배열에서 중복되지 않는 문자만을 뽑아내 배열로 반환해주는 함수</p><pre><code class="swift">/* &gt; Input : [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;e&quot;, &quot;d&quot;, &quot;c&quot;] &gt; Output : [&quot;b&quot;, &quot;e&quot; ,&quot;d&quot;]*/func uniqArr(inputArr: [String]) -&gt; [String] {    var result = [String]()     // 유일한 값일때만 남기는 용도    var check = [String]()      // 두 번째로 들어오는 값인지 확인    for item in inputArr {        if result.contains(item) {            if let index = result.index(of: item) {                result.remove(at: index)            }        } else {            result.append(item)            check.append(item)        }    }    return result}</code></pre><br><p>&lt;4.&gt; 자연수를 입력받아 그 숫자보다 작거나 같은 모든 소수와 그 개수를 출력하는 함수를 정의</p><pre><code class="swift">/* &gt; Input : 10 &gt; Output : 10보다 작거나 같은 소수는 [2, 3, 5, 7]이고, 총 4개입니다.*/func primeNum(number: Int) -&gt; Bool {    var isPrime = true    for i in 2...number-1 {        if number % i == 0 {            isPrime = false        }    }    return isPrime}func checkPrimeNumbers1(number: Int) -&gt; String {    guard number &gt; 1 else { return &quot;1은 소수가 아닙니다.&quot; }    var arr = [2]    for i in 3...number {        if primeNum(number: i) {            arr.append(i)        }    }    return &quot;\(number)보다 작거나 같은 소수는 \(arr), 총\(arr.count)개입니다.&quot;}</code></pre><br><p>&lt;5.&gt; 구글(google), 카카오(kakao), 네이버(naver) 로그인을 위해 Site라는 이름의 Enum 타입을 만들고자 합니다.</p><p> 각 case는 사용자의 아이디(String)와 비밀번호(String)를 위한 연관 값(associated value)을 가집니다.</p><p> 그리고 Site 타입 내부에는 signIn()이라는 이름의 메서드를 만들어 다음과 같이 문자열을 출력하는 기능을 구현해보세요.</p><pre><code class="swift">/*e.g. enum Site {} &gt; Input let google = Site.google(&quot;google@gmail.com&quot;, &quot;0000&quot;) google.signIn() &gt; Output 구글에 로그인하였습니다. (아이디 - google@gmail.com, 비밀번호 - 0000)*/</code></pre>]]></content>
    
    
    <categories>
      
      <category>TIL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>UI-TIL-191127</title>
    <link href="undefined2019/11/UI-TIL-191127/"/>
    <url>2019/11/UI-TIL-191127/</url>
    
    <content type="html"><![CDATA[<h1 id="UI-Guide"><a href="#UI-Guide" class="headerlink" title="UI Guide..?"></a>UI Guide..?</h1><blockquote><p>19년 11월 22일에 배운 내용이지만, 당일에 typora 글을 올리고 배운 내용은 <a href="https://github.com/jisng/TIL/tree/master/FastCampus/19.11.22_(UI)" target="_blank" rel="noopener">깃헙</a> 에만 올렸기 때문에 .. 오늘에서야 코드도 추가하여 올립니다. </p></blockquote><br><p>Frame, Bounds 이런 내용은 빼고, 코드로 UIView 올리는 법을 담았습니다. </p><br><ol><li>이미지를 Assets.scassets 파일에 넣습니다.</li><li>기억 포인트 : <ol><li>UIImageView 안에다가 UIImage를 넣는다.</li><li>contentMode 를 활용하여 만든 ImageView에 Image를 어떻게 채울 지 설정한다.</li></ol></li></ol><pre><code class="swift">let imgView = UIImageView()func createImg(_ img: UIImageView) {        img.frame = CGRect(x: 0, y: 0, width: view.frame.width / 2, height: view.frame.height / 2)        img.image = UIImage(named: &quot;firecracker&quot;)        img.backgroundColor = .red        img.contentMode = .bottomRight        img.contentMode = .scaleAspectFit        view.addSubview(img)    }</code></pre><br><p>끝! </p>]]></content>
    
    
    <categories>
      
      <category>TIL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Alert/TextField-TIL-191126</title>
    <link href="undefined2019/11/Alert-TextField-TIL-191126/"/>
    <url>2019/11/Alert-TextField-TIL-191126/</url>
    
    <content type="html"><![CDATA[<h1 id="AlertController"><a href="#AlertController" class="headerlink" title="AlertController"></a>AlertController</h1><p>얼럿창을 띄웁니다.<br>먼저 버튼을 만든다음, 버튼을 눌렀을 때 얼럿을 띄웁니다.</p><br><p>UIAlertAction(titile:style:handler:) 에 handler 부분에서 해당 버튼을 눌렀을 때 동작하길 원하는 코드를 클로져로 작성합니다. </p><br><p>alert는 present 방식으로 띄웁니다. (화면 전환과 같은 방식이죠!)</p><br><pre><code class="swift">@objc func buttonTab(_ button: UIButton) {        let alertController = UIAlertController(title: &quot;알림&quot;, message: &quot;버튼을 눌러보세요&quot;, preferredStyle: .alert)        let okAction = UIAlertAction(title: &quot;ok&quot;, style: .default) { _ in            print(&quot;ok&quot;)        }        let cancleAction = UIAlertAction(title: &quot;Cancel&quot;, style: .cancel) { _ in            print(&quot;cancel&quot;)        }        let deleteAction = UIAlertAction(title: &quot;Reset&quot;, style: .destructive) { _ in                        print(&quot;delete&quot;)        }        // for 문으로 넣을 수 있음.        alertController.addAction(okAction)        alertController.addAction(cancleAction)        alertController.addAction(deleteAction)        present(alertController, animated: true)    }</code></pre><br><h1 id="TextField"><a href="#TextField" class="headerlink" title="TextField"></a>TextField</h1><p>텍스트필드는 입력을 받는 창인만큼 다양한 속성을 설정할 수 있기 때문에,<br>스토리보드를 통해 어떤 속성들이 있는지 확인 후 코드로 작성하는 것이 좋을 것 같습니다!</p><br><pre><code class="swift">let textField = UITextField()func createTextField (_ text: UITextFiedld) {  text.frame = CGRect(x: , y: , width: , height: )  text.placeholder = &quot;입력하세요.&quot;  text.addTarget(self, action: #selector(tfAction(_:)), for: .editingChanged)  view.addSubView(text)}</code></pre><br><p><code>.addTarget</code> 에서 <code>for</code>  에는 다음 5가지를 호출할 수 있으며, 각 이벤트마다 호출 시점이 다릅니다.  </p><br><p>호출 순서</p><ol><li>.editingDidBegin : textField를 누르면 가장 먼저 호출</li><li>.editingChanged : 값이 입력되면 호출</li><li>.editingdidEndOnExit : 값 입력 멈추고 텍스트 필드를 나가면 호출</li><li>.primaryActionTrigger : 값 입력 후 키보드 리턴 버튼을 누르면 호출</li><li>.editingDidEnd : textField 종료 후 호출</li></ol><br><p>호출 시점을 이용하면,<br>텍스트 필드를 자동으로 띄우거나, 입력 글자 수를 제한하는 등의 기능 구현이 가능합니다.</p>]]></content>
    
    
    <categories>
      
      <category>TIL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>alert</tag>
      
      <tag>textField</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UIViewController-TIL-191125</title>
    <link href="undefined2019/11/UIViewController-TIL-191125/"/>
    <url>2019/11/UIViewController-TIL-191125/</url>
    
    <content type="html"><![CDATA[<h1 id="UIViewController"><a href="#UIViewController" class="headerlink" title="UIViewController"></a>UIViewController</h1><h2 id="The-Role-of-View-Controllers"><a href="#The-Role-of-View-Controllers" class="headerlink" title="The Role of View Controllers"></a><strong>The Role of View Controllers</strong></h2><br><p>앱 구조의 뼈대.<br>모든 앱에 반드시 하나 이상, 대부분 많은 수의 ViewController로 구성</p><ul><li>View Management</li><li>Data Marshaling</li><li>User Interactions</li><li>Resource Management</li><li>Adaptivity</li></ul><br><h2 id="View-Management"><a href="#View-Management" class="headerlink" title="View Management"></a><strong>View Management</strong></h2><br><p>주요 역할 - 뷰 계층 관리<br>모든 뷰컨트롤러마다 RootView를 지나며, 화면에 표시하기 위해서는 해당 RootView 계층에 속해야 한다.</p><br><p><img src="/2019/11/UIViewController-TIL-191125/img1.png" srcset="undefined" alt="img1"></p><br><h2 id="Two-types-of-view-controllers"><a href="#Two-types-of-view-controllers" class="headerlink" title="Two types of view controllers"></a>Two types of view controllers</h2><br><h3 id="Content-View-Controllers"><a href="#Content-View-Controllers" class="headerlink" title="Content View Controllers"></a>Content View Controllers</h3><ul><li>모든 뷰를 단독으로 관리</li><li>UIViewController, UITableViewController, UICollectionViewController􏰋 </li></ul><br><h3 id="Containter-View-Controllers"><a href="#Containter-View-Controllers" class="headerlink" title="Containter View Controllers"></a>Containter View Controllers</h3><ul><li>자체 뷰 + 하나 이상의 자식 뷰 컨트롤러가 가진 루트뷰 관리</li><li>각 컨텐츠를 관리하는 것이 아닌 루트뷰만 관리하여 컨테이너 디자이너에 따라 크기 조정</li><li>UINavigationController, UITabbarController, UIPageViewController 􏰋 </li></ul><br><img src="/2019/11/UIViewController-TIL-191125/img2.png" srcset="undefined" alt="img2" style="zoom:80%;"><br><h2 id="Data-Marshaling"><a href="#Data-Marshaling" class="headerlink" title="Data Marshaling"></a>Data Marshaling</h2><br><p>MVC (Model - View - Controller)</p><br><h2 id="User-Interactions"><a href="#User-Interactions" class="headerlink" title="User Interactions"></a>User Interactions</h2><br><p>이벤트 처리</p><ul><li>뷰컨트롤러는 Responder 객체 : 직접 이벤트를 받아 처리 가능하나 일반적으로 지양</li><li>뷰가 그 자신의 터치 이벤트를 연관된 객체에 action 메서드나 delegate로 전달</li></ul><br><h2 id="Resource-Management"><a href="#Resource-Management" class="headerlink" title="Resource Management"></a><strong>Resource Management</strong></h2><br><p>뷰컨트롤러가 생성한 모든 뷰의 객체들은 뷰컨트롤러의 책임.  </p><p>뷰컨트롤러의 생명 주기에 따라 생성되었다가 자동 소멸되기도 하는 ARC 개념에 맞게 관리 필요.  </p><p>메모리 부족시 didReceiveMemoryWarnig 메서드에서 꼭 유지하지 않아도 되는 자원들은 정리 필요.  </p><br><h2 id="Adaptivity"><a href="#Adaptivity" class="headerlink" title="Adaptivity"></a>Adaptivity</h2><br><p>뷰컨트롤러는 뷰의 표현을 책임지고, 현재 환경에 적절한 방법으로 적용되도록 할 책임을 가진다.</p><img src="/2019/11/UIViewController-TIL-191125/img3.png" srcset="undefined" alt="img3" style="zoom:80%;"><br><hr><br><h1 id="The-View-Controller-Hierarchy"><a href="#The-View-Controller-Hierarchy" class="headerlink" title="The View Controller Hierarchy"></a>The View Controller Hierarchy</h1><br><h2 id="The-Root-View-Controller"><a href="#The-Root-View-Controller" class="headerlink" title="The Root View Controller"></a>The Root View Controller</h2><br><p>UIWindow는 그 자체로 유저에게 보여지는 컨텐츠를 가지지 못함.  </p><p>Window는 정확히 하나의 Root View Controller 를 가지는데 이것을 통해 컨텐츠를 표현</p><img src="/2019/11/UIViewController-TIL-191125/img4.png" srcset="undefined" alt="img4" style="zoom:80%;"><p>실제 표현 되는 것은 View</p><br><h2 id="ViewController-Life-Cycle"><a href="#ViewController-Life-Cycle" class="headerlink" title="ViewController Life Cycle"></a>ViewController Life Cycle</h2><br><img src="/2019/11/UIViewController-TIL-191125/img5.png" srcset="undefined" alt="img5" style="zoom:80%;"><br><h2 id="Presented-View-Controllers"><a href="#Presented-View-Controllers" class="headerlink" title="Presented View Controllers"></a>Presented View Controllers</h2><br><p><img src="/2019/11/UIViewController-TIL-191125/img6.png" srcset="undefined" alt="img6"></p><p>iOS 12 버전까지 위 그림과 같이 “완전히” 덮지만,<br>iOS 13 부터는 카드 모달 형식으로 90%만(..?) 덮습니다.<br>이게 기본이고, 완전히 덮는 방식은 따로 설정해줘야 합니다. </p><br><h2 id="A-container-amp-a-presented-View-Controller"><a href="#A-container-amp-a-presented-View-Controller" class="headerlink" title="A container &amp; a presented View Controller"></a><strong>A container &amp; a presented View Controller</strong></h2><br><p><img src="/2019/11/UIViewController-TIL-191125/img7.png" srcset="undefined" alt="img7"></p><p>UINavigationController 자체로 View 내용을 보여주지 않는다.  </p><p>childViewControllers들의 View 들은  stack형식으로 쌓이고,  </p><p>ChildViewControllers 로 View 로 보여준다.</p><br><hr><br><h1 id="ViewControllerLifeCycle"><a href="#ViewControllerLifeCycle" class="headerlink" title="ViewControllerLifeCycle"></a>ViewControllerLifeCycle</h1><br><p><img src="/2019/11/UIViewController-TIL-191125/vcLifeCycle1.png" srcset="undefined" alt="vcLifeCycle1"></p><p>LoadView -&gt; ViewDidLoad.  </p><p>시스템에서 LoadView를 호출하기 때문에, 직접 호출하는 일은 없다.</p><br><p>will 직전<br>did 직후<br>~ 라고 해석하면 좀 더 쉽게 받아들일 수 있다.</p><br><p><img src="/2019/11/UIViewController-TIL-191125/vcLifeCycle2.png" srcset="undefined" alt="vcLifeCycle2"></p><br><hr><br><h1 id="Card-Style-Modal-Presentation"><a href="#Card-Style-Modal-Presentation" class="headerlink" title="Card Style Modal Presentation"></a>Card Style Modal Presentation</h1><br><h2 id="Card-Style-Lifecycle"><a href="#Card-Style-Lifecycle" class="headerlink" title="Card-Style Lifecycle"></a>Card-Style Lifecycle</h2><br><h3 id="Presented"><a href="#Presented" class="headerlink" title="Presented"></a>Presented</h3><table><thead><tr><th align="center"></th><th align="center">fulll screen - style</th><th align="center">sheet - style</th></tr></thead><tbody><tr><td align="center">Presenting</td><td align="center">ViewWillDisappear</td><td align="center"></td></tr><tr><td align="center">Presented</td><td align="center">ViewWillAppear</td><td align="center">ViewWillAppear</td></tr><tr><td align="center">Presented</td><td align="center">ViewDidAppear</td><td align="center">ViewDidAppear</td></tr><tr><td align="center">Presenting</td><td align="center">ViewDidDisappear</td><td align="center"></td></tr></tbody></table><br><h3 id="Dismiss"><a href="#Dismiss" class="headerlink" title="Dismiss"></a>Dismiss</h3><table><thead><tr><th align="center"></th><th align="center">Full screen - style</th><th align="center">sheet - style</th></tr></thead><tbody><tr><td align="center">Presented</td><td align="center">ViewWillDisappear</td><td align="center">ViewWillDisappear</td></tr><tr><td align="center">Presenting</td><td align="center">ViewWillAppear</td><td align="center"></td></tr><tr><td align="center">Presenting</td><td align="center">ViewDidAppear</td><td align="center"></td></tr><tr><td align="center">Presented</td><td align="center">ViewDidDisappear</td><td align="center">ViewDidDisappear</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><br><h2 id="Dismiss-Gesture-Dismiss"><a href="#Dismiss-Gesture-Dismiss" class="headerlink" title="Dismiss Gesture - Dismiss"></a>Dismiss Gesture - Dismiss</h2><p><code>.isModallInPresentation</code> 을 사용하여, 어떤 값을 받기 전까지 카드를 내릴 수 없게 할 수 있다.</p><pre><code class="swift">// viewDidLoad 에서isModalInPresentation = true // 다음 화면으로 넘어갈 때 버튼 기능으로 nextVC.isModalInPresentation = true</code></pre><br><h3 id="UIAdaptivePresentationControllerDelegate"><a href="#UIAdaptivePresentationControllerDelegate" class="headerlink" title="UIAdaptivePresentationControllerDelegate"></a>UIAdaptivePresentationControllerDelegate</h3><img src="/2019/11/UIViewController-TIL-191125/dismissGesture.png" srcset="undefined" alt="dismissGesture" style="zoom:80%;"><p>델리게이트 배우면 다시 공부해 볼 .. ㅠ</p>]]></content>
    
    
    <categories>
      
      <category>TIL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>UIViewController</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Typora-TIL-191122</title>
    <link href="undefined2019/11/TIL-191122/"/>
    <url>2019/11/TIL-191122/</url>
    
    <content type="html"><![CDATA[<h1 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h1><br><p>이미지 넣기 그렇게 편하다는 Typora.<br>이미지 파일 드래그앤드롭 하면 끝이라고 해서 써보니까 안되던데요..???<br>이걸로 README.md 썼는데, 이미지 안올라가서 5번은 add-commit-push 했거든요<br>알고보니 초반에 설정을 해야 했습니다…</p><br><p>왜 아무도 안알려줬어?<br>.. 왜 나만 몰랐어 ..?</p><br><p>혹시 저 같은 분이 계실까봐 이렇게 블로그를 열었습니다.  </p><br><p>이미지 외에도 해놓으면 편한 설정도 적어봤습니다.</p><h2 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h2><br><p>md 파일에 쓸 이미지들은 img 폴더에 넣어서 쓸거에요.<br>먼저 md 파일이 있는 곳에 img 폴더를 만듭니다.<br>이미지 파일 이름은 영어로 만들어주세요.  </p><p><img src="/2019/11/TIL-191122/folderTree.png" srcset="undefined" alt="folderTree"></p><br><p>Typora 를 연 뒤 이미지 설정을 하러 들어갑니다.<br>서식 &gt; 이미지 &gt; 전역 이미지 설정…</p><p><img src="/2019/11/TIL-191122/setting1.png" srcset="undefined" alt="setting1"></p><br><p>다음과 같이 체크해줍니다.<br>로컬 이미지에 위 규칙을 적용 / 가능하다면 상대적 위치 사용</p><p><img src="/2019/11/TIL-191122/setting2.png" srcset="undefined" alt="setting2"></p><p>보통 아무 설정이 없는 경우 ‘절대 경로’를 통해 이미지 파일을 불러오는데요, 그 상태로 깃헙이나 블로그에 올리면 이미지 파일을 못찾습니다.<br>‘상대적 위치 사용’을 눌러주면,<br><code>/User ~</code> 하면서 절대 경로 파일을 불러 오던 것이<br><code>img/img1.png</code> 라고 상대 경로로 파일을 불러집니다.  </p><br><p>그럼 이제 Typora 키셔서 이미지를 <strong>드래그앤드롭</strong> 해서 올려보세요. </p><br><p>끝.</p><br><p>이미지 올리기 정말 편하죠 ㅠㅠ (감격)</p><br><h2 id="Terminal-Command"><a href="#Terminal-Command" class="headerlink" title="Terminal Command"></a>Terminal Command</h2><br><p>터미널에서 md 파일 열어서 작성할 때 설마 vi 쓰시나요? </p><br><p>정말 멋있어 .. 최고야 .. </p><br><p>저는 쪼랩이라 macdown으로 열었는데요, 이번에 업데이트하면서 타이핑 할 때마다 화면이 깜빡거리더라고요. 못쓰겠어요.<br>Typora로 갈아탔으니, 이제 이걸로 열려고 하는데… 안열려요. (참고로 저는 zsh).  </p><br><p><code>typora README.md</code> 이렇게 여는 법을 typora 공식 홈페이지에서 가져왔습니다. </p><br><pre><code>// 터미널을 키시고 다음 명령어를 입력하세요.$ vi ~/.zshrc// 아래 내용을 작성해주세요.# Aliasalias typora=&quot;open -a typora&quot;// :wq 명령어 입력 후 빠져나온 뒤, 다음 명령어를 입력하세요.$ source ~/.zshrc</code></pre><br><p>끝!<br>이제 <code>typora README.md</code> 하면 typora 에서 열릴꺼에요!  </p><br><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>더 좋은 기능을 발견하게 된다면 또 작성하겠습니다.<br>오늘 수업시간에 배운 건 UIGuide, Frame, Bounds 였는데, 그거 정리해서 올리려다가 불편함이 극에 달해 구글링한게 이렇게 TIL 까지 나왔네요!<br>더 좋은 팁 있으면 저도 알려주세요 :)) </p>]]></content>
    
    
    <categories>
      
      <category>TIL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Typora</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TIL-191121-Xcode 시작하기</title>
    <link href="undefined2019/11/TIL-191121/"/>
    <url>2019/11/TIL-191121/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/jisng/TIL/tree/master/FastCampus/19.11.21_(AppLifeCycle+Xcode1)" target="_blank" rel="noopener">AppLifeCycle</a></p></blockquote><h1 id="Xcode-1-Setting"><a href="#Xcode-1-Setting" class="headerlink" title="Xcode 1 : Setting"></a>Xcode 1 : Setting</h1><h2 id="AppDelegate-swift-SceneDelegate-swift-SETTING"><a href="#AppDelegate-swift-SceneDelegate-swift-SETTING" class="headerlink" title="AppDelegate.swift, SceneDelegate.swift SETTING"></a>AppDelegate.swift, SceneDelegate.swift SETTING</h2><p>WWDC2019 대격변 업데이트로 인해 다음 중 선택해야 하는 상황이 생겼습니다.</p><ol><li>SceneDelegate.swift 사용 : <ol><li>iOS 13 미만 (현업, 개인앱 사용시) :<br> SceneDelegate.swift, AppDelegate.swift : SceneSession -&gt; <code>@available (iOS13, *)</code><br> AppDelegate.swift -&gt; <code>var window: UIWindow?</code> 추가</li><li>iOS 13 이상 :<br> 델리게이트 사용이 필요한 순간 직전까지 AppDelegated.swift, SceneDelegate.swift 무시 (ㅋㅋ)</li></ol></li><li>SceneDelegate 사용하지 않을 때 : <ul><li>SceneDelegate 파일 삭제</li><li>AppDelegate에서 Scene과 관련 된 코드 삭제</li><li>Info.Plist &gt; Application Scene Mainfest 키 삭제</li><li>AppDelegate 안에 <code>var window: UIWindw?</code> 작성</li></ul></li></ol><br><p>저는 다음과 같이 셋팅하고 공부할꺼에요. </p><pre><code class="swift">import UIKit@UIApplicationMainclass AppDelegate: UIResponder, UIApplicationDelegate {var window: UIWindow?    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool {        // Override point for customization after application launch.        return true    }    func applicationDidBecomeActive(_ application: UIApplication) {    }    func applicationWillResignActive(_ application: UIApplication) {    }    func applicationDidEnterBackground(_ application: UIApplication) {    }    func applicationWillEnterForeground(_ application: UIApplication) {    }    func applicationWillTerminate(_ application: UIApplication) {    }}</code></pre><h2 id="code-UI"><a href="#code-UI" class="headerlink" title="code UI"></a>code UI</h2><br><p>책으로 공부했을 때 스토리보드로 버튼 만들고 했기 때문에, 이번에는 코드로 만드는 방법 위주로 연습하고 처음 보는 기능(?)들은 스토리보드로도 추가 학습하기로 마음 먹었어요!</p><br><p><strong>중요 포인트</strong></p><br><p><code>didFinshLaunchingWithOptions ~</code> func 안에 다음과 같은 코드 꼭꼭 넣어야 합니다.   </p><pre><code class="swift">window = UIWindow(frame: UIScreen.main.bounds)window?.rootViewController = ViewController()window?.makeKeyAndVisible()</code></pre><p>스토리보드 파일이 없는 상태에서,<br>윈도우에게 루트뷰를 지정해주는 코드입니다. </p><br><p><img src="/2019/11/TIL-191121/스크린샷.png" srcset="undefined" alt="image"></p><p>마지막으로 General &gt; Deployment Info &gt; Main Interface 이 부분을 지워주면 코드로 UI 짤 준비 끝! 입니다.</p><br><p>스토리보드로 버튼이나 레이블을 만들 때, <code>viewDidLoad</code> 밖에다가 했었습니다.<br>코드로 짤 때는 <code>viewDidLoad</code> 안에다가 만드는데요,<br>스토리보드에서  @IBOutlet 에 해당하는 내용을 이 안에다 짜고, func은 (당연하게도) 밖에다가 짭니다.<br>또 당연히 <code>let label = UILable()</code> 과 같이 할당된 변수는 밖에다 짜도 됩니다. (상태 변경을 위해서는 밖에다 짜야 하는데, 제가 처음에 그걸 몰라서 엄청 엄청 삽질을.. 하아….) </p><br><h3 id="view-위에-view-올리기"><a href="#view-위에-view-올리기" class="headerlink" title="view 위에 view 올리기"></a>view 위에 view 올리기</h3><br><pre><code class="swift">let blueView = UIView()        blueView.backgroundColor = .systemBlue        blueView.frame = CGRect(x: 150, y:100, width: 100, height: 100)        view.addSubview(blueView)        let redView = UIView()        redView.backgroundColor = .systemRed        redView.frame = CGRect(x: 150, y: blueView.frame.maxY + 100, width: 100, height: 100)        view.addSubview(redView)        let greenView = UIView()        greenView.backgroundColor = .systemGreen        greenView.frame = CGRect(x: 150, y: redView.frame.origin.y + 300, width: 100, height: 100)        view.addSubview(greenView)</code></pre><br><h3 id="button"><a href="#button" class="headerlink" title="button"></a>button</h3><br><pre><code class="swift">let button = UIButton(type: .system)        button.setTitle(&quot;버튼버튼&quot;, for: .normal)        button.setTitleColor(.red, for: .selected)        button.frame = CGRect(x: 100, y: 500, width: 200, height: 20)        view.addSubview(button)        button.addTarget(self, action: #selector(didTapButton), for: .touchUpInside)        // 타켓 나 자신이 처리할게</code></pre><p><code>viewDidLoad</code> 벗어나서</p><pre><code class="swift">    @objc func didTapButton(_ sender: UIButton) {        print(&quot;버튼탭탭&quot;)        sender.setTitleColor(.yellow, for: .normal)    }</code></pre><br><h3 id="label"><a href="#label" class="headerlink" title="label"></a>label</h3><br><pre><code class="swift">let label = UILabel()        label.frame = CGRect(x: 180, y: 100, width: 400, height: 400)        label.text = &quot;레이블&quot;        label.font = label.font.withSize(50)        view.addSubview(label)</code></pre><h4 id="팁-시뮬레이터-전체화면"><a href="#팁-시뮬레이터-전체화면" class="headerlink" title="팁 : 시뮬레이터 전체화면"></a>팁 : 시뮬레이터 전체화면</h4><br><p>터미널에 다음과 같이 입력한 후,  </p><pre><code class="swift">defaults write com.apple.iphonesimulator. AllowFullscreenMode -bool YES</code></pre><p>시뮬레이터를 완전히 종료시킨 후 <em>Command + Q</em><br>다시 키면 전체 화면 <em>Command + Control + F</em> 됩니다.</p>]]></content>
    
    
    <categories>
      
      <category>TIL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Xcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TIL-swift-OOP2-191119</title>
    <link href="undefined2019/11/TIL-swift-OOP2-191119/"/>
    <url>2019/11/TIL-swift-OOP2-191119/</url>
    
    <content type="html"><![CDATA[<h1 id="Access-Control"><a href="#Access-Control" class="headerlink" title="Access Control"></a>Access Control</h1><blockquote><p>이 부분은, 개념적인 부분만 가볍게 훑고 지나간 뒤 나중에 실제 코드를 만났을 때 다시 살펴보기로 합니다. </p></blockquote><br><ul><li>다른 모듈의 코드 또는 다른 소스 파일 등으로부터 접근을 제한하는 것</li><li>세부 구현 내용을 숨기고 접근할 수 있는 인터페이스 지정 가능</li></ul><br><ul><li>모듈 <em>Module</em><ul><li>import 를 통해 다른 모듈로부터 불러들일 수 있는 하나의 코드 배포 단위</li><li>Library / Framework / Application </li></ul></li><li>소스 파일 <em>Source File</em><ul><li>모듈 내에 포함된 각각의 Swift 소스 코드 파일</li></ul></li></ul><h2 id="Access-Levles"><a href="#Access-Levles" class="headerlink" title="Access Levles"></a>Access Levles</h2><br><ul><li>5가지<ul><li>open</li><li>public</li><li>internal</li><li>fileprivate</li><li>private</li></ul></li></ul><p><img src="/2019/11/TIL-swift-OOP2-191119/swift_access_levels.png" srcset="undefined" alt="swift_access_levels"><br><img src="/2019/11/TIL-swift-OOP2-191119/swift_access_levels2.png" srcset="undefined" alt="swift_access_levels2"></p><br><pre><code class="swift">fileprivate class SomeFileprivateClass {   var name = &quot;name&quot;   var age = 0}fileprivate let someFileprivateClass = SomeFileprivateClass()someFileprivateClass.namesomeFileprivateClass.age</code></pre><pre><code class="swift">class SomePrivateClass {  private var name = &quot;name&quot;  private var age = 0  func someFunction() {    print(name) // 간접 접그  }}let somePrivateClass = SomePrivateClass()somePrivateClass.someFunction()// 접근불가 // somePrivateClass.name //  Error! // &#39;name&#39; is inaccessible due to &#39;private&#39; protection level// 접근불가 // somePrivateClass.age // Error! // &#39;age&#39; is inaccessible due to &#39;private&#39; protection level</code></pre><p>정리 :<br><code>Internal</code>과 <code>Public</code>은 생략 가능합니다.  </p><h3 id="Nested-Types"><a href="#Nested-Types" class="headerlink" title="Nested Types"></a>Nested Types</h3><br><table><thead><tr><th align="center">Class</th><th align="center">-&gt;</th><th align="center">Property</th></tr></thead><tbody><tr><td align="center">Private</td><td align="center">-&gt;</td><td align="center">Fileprivate</td></tr><tr><td align="center">Fileprivate</td><td align="center">-&gt;</td><td align="center">Fileprivate</td></tr><tr><td align="center">Internal</td><td align="center">-&gt;</td><td align="center">Internal</td></tr><tr><td align="center">Public</td><td align="center">-&gt;</td><td align="center">Internal</td></tr><tr><td align="center">Open</td><td align="center">-&gt;</td><td align="center">Internal</td></tr></tbody></table><br><h3 id="Getters-and-Setters"><a href="#Getters-and-Setters" class="headerlink" title="Getters and Setters"></a>Getters and Setters</h3><pre><code class="swift">class TrackedString {//  var numberOfEdits = 0//  private var numberOfEdits = 0  private(set) var numberOfEdits = 0 // 수정할 수는 없지만 읽어올 수는 있도록  var value: String = &quot;&quot; {    didSet {      numberOfEdits += 1    }  }</code></pre><br><h1 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h1><br><h2 id="OOP-4대-특징"><a href="#OOP-4대-특징" class="headerlink" title="OOP 4대 특징"></a>OOP 4대 특징</h2><br><ul><li>추상화</li><li>캡슐화<ul><li>은닉화     </li></ul></li><li>상속성</li><li>다형성</li></ul><br><h3 id="Abstracion-추상화"><a href="#Abstracion-추상화" class="headerlink" title="Abstracion(추상화)"></a>Abstracion(추상화)</h3><br><ul><li>불필요한 부분을 지워 단순화<ul><li>사물들 간의 공통점으로 일반화, 단순화</li><li>중요 부분을 강조를 위해 단순화</li></ul></li><li>관심 영역 = 도메인 = 컨텍스트 / 추상화 = 모델링 = 설계</li></ul><br><p>추상화는 대상에 대한 관점과 사용 목적에 따라 달라진다고 합니다.<br>모두가 인간을 표현하기 위한 필수 요소에 대해 완벽히 똑같이 말하지 않는 것과 같은 논리입니다.  </p><br><p><strong>Protocol</strong></p><pre><code class="swift">Q. 추상화 적용해보기 (Protocol 로 표현)// 사람(Human)을 표현하는 속성과 동작 정의// 레스토랑을 운영하는 오너(Owner)의 속성과 동작 정의// 요리사(Chef)의 속성과 동작 정의// 손님(Customer)의 속성과 동작 정의</code></pre><h3 id="Encapsulation-캡슐화"><a href="#Encapsulation-캡슐화" class="headerlink" title="Encapsulation(캡슐화)"></a>Encapsulation(캡슐화)</h3><br><p>Encapsulation - class, methods, variables</p><br><ul><li>추상화가 디자인 레벨에 해당하는 개념이라면, 캡슐화는 구현 레벨에서의 개념<ul><li>데이터 캡슐화 : 연관된 상태와 행동을 하나의 단위 (객체) 로 캡슐화</li><li>정보 은닉화 : 외부에 필요한 것만 알리고 불필요하거나 감출 정보는 숨김</li></ul></li><li>객체가 독립적으로 자신의 상태와 역할을 책임지고 수행할 수 있도록 자율성 부여</li><li>접근 제한자를 이용해 데이터를 외부로부터 보호</li><li>외부에서 요청을 전달하면 수신 객체는 ‘어떻게’ 처리할 지를 결정. 외부에서 그 내용을 자세히 알 필요 없음</li></ul><br><pre><code class="swift">//Q. 캡슐화 적용해보기//- A가 서울에서 부산까지 여행을 가기로 함//- A의 현재 위치는 currentLocation 이라는 메서드를 통해서만 확인 가능//- 부산으로 이동하는 동작(메서드)을 구현하고 위치의 변경은 이 메서드를 통해서만 가능//- 부산까지 이동하는 도중에 다른 일들을 할 수 있지만 외부에서는 자세한 내용은 알거나 수정하지 못함</code></pre><h3 id="Inheritance-상속성"><a href="#Inheritance-상속성" class="headerlink" title="Inheritance(상속성)"></a>Inheritance(상속성)</h3><br><ul><li>하나의 클래스의 특징(부모 클래스)을 다른 클래스가 물려받아 그 속성과 기능을 동일하게 사용하는 것</li><li>범용적인 클래스를 작성한 뒤 상속을 이용해 중복되는 속성솨 기능을 쉽게 구현</li><li>주요 목적 : 재사용과 확장</li></ul><br><pre><code class="swift">//Q. Person, Student, University Student 클래스 구현하고 관련 속성 및 메서드 구현//상속을 하지 않고 각각 개별적으로 만들면 어떻게 구현해야 하는지 확인//상속을 적용하면 어떻게 바뀌는지 확인</code></pre><h3 id="Polymorphism-다형성"><a href="#Polymorphism-다형성" class="headerlink" title="Polymorphism(다형성)"></a>Polymorphism(다형성)</h3><br><ul><li>다양한 형태로 나타날 수 있는 능력</li><li>동일한 요청에 대해 각각 다른 방식으로 응답할 수 있도록 만드는 것</li><li>오버라이딩과 오버로딩이 있으며 언어에 따라 오버라이딩만 지원하기도 함<ul><li>오버라이딩 :<ul><li>상위 클래스에서 상속 받은 메서드를 하위 클래스에서 필요에 따라 재정의</li><li>동일 요청이 객체에 따라 다르게 응답</li></ul></li><li>오버로딩 :<ul><li>동일한 이름의 메서드가 매개 변수의 이름, 타입, 개수 등의 차이에 따라 다르게 동작하는 것</li><li>동일 요청이 매개 변수에 따라 다르게 응답 </li></ul></li></ul></li></ul><br><pre><code class="swift">class Shape {  var title = &quot;Shape&quot;  var color = UIColor.black  // 변경 불가  final var lineWidth = 3  let unit = &quot;cm&quot;  init(color: UIColor) {    self.color = color  }  func draw() {    print(&quot;draw shape&quot;)  }}let shape = Shape(color: .cyan)shape.colorshape.draw()class Rectangle: Shape {  var cornerRadius = 0.0  // 저장 프로퍼티 X  //  override var color: UIColor  = .green  // 계산 프로퍼티 O  override var color: UIColor {    get {      return super.color    }    set {      super.color = newValue    }  }  override var title: String {    get {      //      return &quot;Rectangle&quot;      return super.title + &quot; =&gt; Rectangle&quot;    }    set {      super.title = newValue    }  }  init(color: UIColor, cornerRadius: Double = 10.0) {    super.init(color: color) //    self.cornerRadius = cornerRadius  }}let rect = Rectangle(color: UIColor.blue)rect.colorrect.color = .yellowrect.colorrect.cornerRadiusrect.lineWidthrect.draw()shape.titlerect.titleclass Triangle: Shape {  override func draw() {    super.draw()    print(&quot;draw triangle&quot;)  }}let triangle = Triangle(color: .gray)triangle.titletriangle.lineWidthtriangle.color//triangle.cornerRadius    //triangle.draw()</code></pre>]]></content>
    
    
    <categories>
      
      <category>TIL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>swift</tag>
      
      <tag>class</tag>
      
      <tag>OOP</tag>
      
      <tag>protocol</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TIL-swift-OOP1-191118</title>
    <link href="undefined2019/11/TIL-swift-OOP1-191118/"/>
    <url>2019/11/TIL-swift-OOP1-191118/</url>
    
    <content type="html"><![CDATA[<h1 id="OOP-Object-Oriented-Programming"><a href="#OOP-Object-Oriented-Programming" class="headerlink" title="OOP : Object-Oriented-Programming"></a>OOP : Object-Oriented-Programming</h1><hr><ul><li>Value Type : struct, enum ( Stack에 저장)</li><li>Reference Type : class ( Heap 에 저장)</li></ul><br><table><thead><tr><th></th><th>x</th><th>y</th><th>z</th></tr></thead><tbody><tr><td>Stack</td><td>5</td><td>0x5F17</td><td>0x2C90</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td>0x2C90</td><td>0x5F16</td><td>0x517</td></tr><tr><td>Heap</td><td>z’s user data</td><td>SomeData</td><td>y’s user data</td></tr></tbody></table><br><h2 id="Equatablem-Identical"><a href="#Equatablem-Identical" class="headerlink" title="Equatablem, Identical"></a>Equatablem, Identical</h2><pre><code class="swift">1 == 1 // True2 == 1 // False&quot;ABC&quot; == &quot;ABC&quot; // Trueclass Person {  let name = &quot;이순신&quot;  let age = 30}let person1 = Person()let person2 = Person()person1 == &quot;이순신&quot;    // 오류, 타입이 다름person1 == person2   // 오류, name과 age 어떤 걸 비교할지 컴파일러는 몰라요</code></pre><br><pre><code class="swift">class User: Equatable {  var name = &quot;이순신&quot;  let age = 30  static func ==(lhs: User, rhs: User) -&gt; Bool {    return lhs.name == rhs.name  }}let user1 = User()var user2 = User()user1 == user2</code></pre><br><ul><li>Equatable Protocol.  </li></ul><pre><code class="swift">class ClassName: SuperClassName, ProtocolName... {   PropertyList   MethodList }let objectName = ClassName() objectName. propertyName objectName. functionName()</code></pre><ul><li>Identical.  </li></ul><pre><code class="swift">/* Identity Operators === : 두 상수 또는 변수가 동일한 인스턴스를 가르키는 경우 true 반환 */user1.name = &quot;라인하르트&quot;user2.name = &quot;브리기테&quot;user1.name   // &quot;라인하르트&quot;user2.name   // &quot;브리기테&quot;user1 == user2 // falseuser1 === user2 // falseuser2 = user1 // user2에 user2을 대입하면서, user2는 user1의 주소[Heap]를 가리키게 된다. // (user2가 쓰던 주소는 컴파일러에 의해 삭제된다.) // 이제 user1의 내장 프로퍼티를 바꾸면 user2의 내장 프로퍼티도 바뀐다. (같은 주소를 가리키게 되니까) // 값 타입과 참조(주소) 타입의 차이 = 메모리 차이 user1.name // 라인하르트user2.name // 라인하르트user1 == user2    // trueuser1 === user2   // trueuser2.name = &quot;윈스턴&quot;user2.name // 윈스턴user1.name // 윈스턴</code></pre><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><br><h3 id="Class-Initilalize"><a href="#Class-Initilalize" class="headerlink" title="Class Initilalize"></a>Class Initilalize</h3><br><ul><li>초기화(init)가 불필요한 경우 : 모든 저장 프로퍼티에 초기값이 설정되어 있음</li><li>초기화(init)가 필요한 경우 : 저장 프로퍼티 중 하나 이상이 초기값 미설정됨</li></ul><br><p>1.</p><pre><code class="swift">class Hero {    let name = &quot;mei&quot;    let color = &quot;blue&quot;    func attack() {        print(&quot;퍽&quot;)    }</code></pre><p>2.</p><pre><code class="swift">class Here {    let name: String    let color: String    init() {        name = &quot;mei&quot;        color = &quot;blue&quot;    }    func attack() {        print(&quot;퍽&quot;)    }</code></pre><p>3.</p><pre><code class="swift">class Hero {    let name: String    let color: String    init(name: String, color: String) {        self.name = name        self.color = color    }    func attack() {        print(&quot;퍽&quot;)    }</code></pre><blockquote><p>self 를 써서 클래스 내 프로퍼티인지, 함수에서 받는 파라미터인지 구분할 수 있다.</p></blockquote><br><hr><br><h2 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h2><br><table><thead><tr><th>⬇︎</th><th align="center">Stored</th><th align="center">Lazy</th><th align="center">Computed</th><th align="center">Observer</th><th align="center">Type</th></tr></thead><tbody><tr><td>Class</td><td align="center">⭕️</td><td align="center">⭕️</td><td align="center">⭕️</td><td align="center">⭕️</td><td align="center">⭕️</td></tr><tr><td>Structure</td><td align="center">⭕️</td><td align="center">⭕️</td><td align="center">⭕️</td><td align="center">⭕️</td><td align="center">⭕️</td></tr><tr><td>Enum</td><td align="center">❌</td><td align="center">❌</td><td align="center">⭕️</td><td align="center">❌</td><td align="center">⭕️</td></tr></tbody></table><br><h3 id="Stored-Property"><a href="#Stored-Property" class="headerlink" title="Stored Property"></a>Stored Property</h3><ul><li>Class ⭕️</li><li>Structure ⭕️</li><li>Enumeration ❌</li></ul><pre><code class="swift">class StoredProperty {  var width = 0.0  var height = 0.0}let stored = StoredProperty()stored.width = 123stored.height = 456</code></pre><br><h3 id="Lazy-Stored-Property"><a href="#Lazy-Stored-Property" class="headerlink" title="Lazy Stored Property"></a>Lazy Stored Property</h3><ul><li>Class ⭕️</li><li>Structure ⭕️</li><li>Enumeration ❌</li><li>초기값이 인스턴스의 생성이 완료될 때까지도 알 수 없는 외부 요인에 의존할 때</li><li>초기값이 복잡하거나 계산 비용이 많이 드는 설정을 필요로 할 때</li><li>필요한 경우가 제한적일 때</li></ul><pre><code class="swift">class LazyStoredProperty {  var width = 10.0  var height = 20.0  // 1. 외부 요인이나 다른 설정에 기반//  var area = self.width * self.height  lazy var area = width * height  // 2. 계산 비용이 많이 드는 상황//  var hardWork = &quot;실행하면 약 10초 이상 걸려야 하는 작업&quot;  // 3. 필요한 경우가 제한적인 상황//  func ifStatement() {//    if true {   // 10%//      print(area)//    } else {    // 90%//      print(width)//    }//  }}let lazyStored = LazyStoredProperty()// width, height 초기화lazyStored.width = 30// area 최초 호출되는 시점에 초기화lazyStored.area// lazy 기능// 순서 주의let lazyStored1 = LazyStoredProperty()lazyStored1.area // 200lazyStored1.width = 30lazyStored1.area // 이미 위에서 호출되어 초기화가 되었기 때문에, 지정된 값 그대로 나온다. // 한 번 저장되면 따로 바꿔주지 않는 이상 그대로 저장되어 있음.lazyStored1.area = 600</code></pre><br><h3 id="Computed-Property"><a href="#Computed-Property" class="headerlink" title="Computed Property"></a>Computed Property</h3><ul><li>Class ⭕️</li><li>Structure ⭕️</li><li>Enumeration ⭕️ </li><li>자료를 저장하지 않고 매번 호출할 때마다 새로 계산</li></ul><pre><code class="swift">var name: type {    get {        statements    }    set {        name = newValue    }}</code></pre><pre><code class="swift">class ComputedProperty {  var width = 5.0  var height = 5.0  lazy var lazyArea = width * height  var area: Double {    return width * height  }  // Stored + Computed get(read), set(write)  private var _koreanWon = 0.0  var wonToDollar: Double {    get {      return _koreanWon / 1136.5    }    set {      _koreanWon = newValue // newValue는 set에 들어오는 값을 기본적으로 담게 내장되있음    }    /*     set (myValue) {        _koreanWon = myValue     }     이렇게도 사용할 수 있음     */  }}var computed = ComputedProperty()computed.areacomputed.lazyAreacomputed.width = 10computed.areacomputed.lazyAreacomputed.lazyArea = 50.0computed.lazyAreacomputed.width = 20computed.height = 20computed.areacomputed.lazyAreacomputed.wonToDollarcomputed.wonToDollar = 10000computed.wonToDollar</code></pre><br><h4 id="Property-Observer"><a href="#Property-Observer" class="headerlink" title="Property Observer"></a>Property Observer</h4><ul><li>Class ⭕️</li><li>Structure ⭕️</li><li>Enumeration ❌</li></ul><pre><code class="swift">var name: type = value {    willSet { //변수에 값이 바뀌기 직전에 호출        statements    }    didSet { // 변수에 값이 바뀐 직후에 호출        statements    }</code></pre><pre><code class="swift">class PropertyObserver {  var height = 0.0  var width = 0.0 {    willSet {      print(&quot;willSet :&quot;, width, &quot;-&gt;&quot;, &quot;newValue :&quot;, newValue)    }    didSet {      print(&quot;didSet :&quot;, oldValue, &quot;-&gt;&quot;, &quot;width :&quot;, width)      height = width / 2    }  }}var obs = PropertyObserver()obs.height = 456obs.width = 123</code></pre><br><h4 id="Type-Property"><a href="#Type-Property" class="headerlink" title="Type Property"></a>Type Property</h4><ul><li>Class ⭕️</li><li>Structure ⭕️</li><li>Enumeration ⭕️ </li><li>Shared</li><li>Lazily Initialized</li></ul><pre><code class="swift">선언 - static let(var) propertyName: Type 또는class var propertyName: Type { return code }사용 - TypeName. propertyName static: override 불가 class: 클래스에서만 사용 가능하고 computed property 형태로 사용. 서브클래스에서 override 가능</code></pre><pre><code class="swift">class TypeProperty {  static var unit: String = &quot;cm&quot;  var width = 5.0}let square = TypeProperty()square.widthlet square1 = TypeProperty()square1.width = 10.0square1.widthTypeProperty.unitprint(&quot;\(square.width) \(TypeProperty.unit)&quot;) // 5.0cmprint(&quot;\(square1.width) \(TypeProperty.unit)&quot;)TypeProperty.unit = &quot;m&quot;print(&quot;\(square.width) \(TypeProperty.unit)&quot;) // 5.0mprint(&quot;\(square1.width) \(TypeProperty.unit)&quot;)</code></pre>]]></content>
    
    
    <categories>
      
      <category>TIL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>swift</tag>
      
      <tag>class</tag>
      
      <tag>property</tag>
      
      <tag>OOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TIL-contribution-191116</title>
    <link href="undefined2019/11/TIL-contribution-191116/"/>
    <url>2019/11/TIL-contribution-191116/</url>
    
    <content type="html"><![CDATA[<h1 id="오픈소스에-PR-보낸-경험"><a href="#오픈소스에-PR-보낸-경험" class="headerlink" title="오픈소스에 PR 보낸 경험"></a>오픈소스에 PR 보낸 경험</h1><br><blockquote><p>제목만 보면 엄청 대단한 걸 줄 알겠지만, 그렇지 않습니다.<br>왜냐면 “번역” 이거든요.<br>단어만 60개여서 번역이라고 하기도 민망하네요 ㅎ.. </p></blockquote><br><h2 id="계기"><a href="#계기" class="headerlink" title="계기"></a>계기</h2><br><p>지금 사용중인 hexo theme - cactus 에서 카테고리 메뉴를 추가 하고 싶어서, 동현님께 도움을 구하러 갔습니다.<br>설정 방법을 확인하려고 테마의 깃헙 페이지를 열어서 찾아보는데, 갑자기 동현님이,<br>“어, 이거 한국어 파일 없네요?”<br>“어떻게 되어 있나 그냥 봐볼까..” 라며 열었는데,<br>아주 단순한 단어가 1줄에 1개씩, 60줄로 적혀있었어요. (문장 아니고 진짜 단어만)<br>“이거 뭐 금방 하겠는데요? 이거 만들어요!”<br>라고 얘기하시는거에요!!!   </p><br><p>안그래도 깃특강 들을 때 강사님이 테마 번역해서 기여한거 있다며 보여주셨거든요.<br>이런것도 오픈소스 기여 아니겠냐며~<br>가볍게 도전할 수 있으니 해봐라~ 라는 얘기를 하셨어요.</p><br><p><strong>해봤습니다.</strong></p><br> <p>이게 말로만 듣던 “오픈소스 기여”란 말인가 (거창)</p><br><p>낄낄</p><br><h2 id="실전"><a href="#실전" class="headerlink" title="실전"></a>실전</h2><br><p>강사님께 배웠던 대로 일단 포크떠서 가져옵니다.<br>(깃헙 특강 정말 좋았음. 너무 명쾌해서)</p><ol><li>fork</li><li><code>git clone ~</code></li></ol><br><p>그리고 시작된 고민들.</p><br><h3 id="1차-고민"><a href="#1차-고민" class="headerlink" title="1차 고민."></a>1차 고민.</h3><ul><li>마스터로 작업해야 하나?</li><li>브랜치로 작업해야 하나?</li></ul><br><p>분명 조별 협업 실습을 했는데, 그 때 뭔가 쫓기듯이 해서 기억이 잘 …<br>git flow 를 썼었고 … start - 작업 - finish 순서로 했는데 …<br>그 때 master 로 안보내고 develop 으로 보냈으니까 어쨌든 브랜치로 보낸거겠지 ..?  </p><p>브랜치로 작업하기 결정했습니다.  </p><br><p>이 부분을 동현님께 디엠 보냈을 때, 마스터로 작업해도 된다고 하셨거든요.<br>근데 제가 디엠 보내기 전에 구글링 해보니까 브랜치로 작업한다는 내용만 보였습니다.<br><em>제가 하는 참여가 기능에 타격을 줄만한 큰 일이 아니어서 마스터에 해도 되는 거였을까요?</em>  </p><br><p>제가 내린 결론 : <strong>보통은 해당 오픈소스 기여방식이 README에 적혀있으나,</strong><br>저처럼 안적혀있는 경우, 안전하게 브랜치 작업하는게 좋지 않을까 생각됩니다. </p><br><h3 id="2차-고민"><a href="#2차-고민" class="headerlink" title="2차 고민."></a>2차 고민.</h3><ul><li>Compare &amp; pull request?</li><li>Pull request?</li></ul><br><p>수업 시간에 사용했던 건,<br>오른쪽 상단에 작은 회색 글씨로 써져있는 ‘Pull request’ 버튼이었는데<br>깃헙 페이지에 들어가보니 그 위에 초록색 버튼이 누르고 싶게 떴어요 !!<br>‘Comepare &amp; pull request’  </p><br><p>구글링도 해보고 눌러도 봤는데, 둘이 차이가 있..나? 싶더라고요.<br>하지만 전 처음이니까 너무 불안했습니다.  </p><br><p>… 결국 강사님께 디엠 보냈습니다.</p><br><p>답이 왔어요 : <strong>둘 중 뭘 눌러도 상관없습니다.</strong></p><br><h3 id="3차-고민"><a href="#3차-고민" class="headerlink" title="3차 고민."></a>3차 고민.</h3><ul><li>master 에다 보내야 하나?</li><li>branch 에다 보내야 하나?</li></ul><p>오픈소스 브랜치를 눌러보니, 어디다 보내야 할 지 모르겠는 이름 달랑 두 개.  </p><p>구글링 했을 때도, 동현님이 말씀하시기도 마스터에 보내지 말라고 했는데 ..  </p><br><p>.. 이것도 강사님께 디엠을 보냈습니다. ( 강사님 감사합니다 )</p><br><p>답이 왔어요 : <strong>마스터로 보내세요</strong></p><br><p><em>블로그 테마에, 그것도 언어 추가 정도의 작은 작업은 너무 빡빡하게 생각하지 않아도 되는건가 싶었습니다</em></p><br><h3 id="4차-고민"><a href="#4차-고민" class="headerlink" title="4차 고민."></a>4차 고민.</h3><ul><li>이슈 쓰고 PR?</li><li>PR 하고 이슈?</li></ul><p>아..<br>정말 하나부터 열까지 다 알려줘야 할 수 있는 나란 초보.  </p><br><p>이것 역시 강사님께 물어봤습니다. ( 실제로 디엠보낼 때 고민을 모아 한 번에 물어봤습니다. )</p><br><p>답이 왔어요 : <strong>이슈 쓰고, PR 하세요</strong></p><br><h2 id="깨달음"><a href="#깨달음" class="headerlink" title="깨달음"></a>깨달음</h2><br><p><strong>인생은 실전이다.</strong></p><br> <p>이번 계기로 오픈소스 기여 방식에 대해 조금 알게 된 것 같습니다.<br>특강 들으면서 “아 뭐~ 이렇게 하는구나~” 했던 것들은 알고 있는게 아니였어요.. 난 아무것도 몰라..  </p><p>아무튼 기여에 대해 제대로 알기 위해서는, 오픈소스에서 기능을 건드리는 참여를 하게 될 때 알게 될 것 같습니다.  </p><br><p><em>그런 날이 올까요..?</em></p><br><h3 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h3><br><p>참여하고 싶은 오픈소스가 있나요?</p><ol><li>README.md 정독 : <em>참여 방식을 숙지합니다.</em></li><li>fork</li><li><code>git clone ~</code></li><li><code>git branch ~</code> : <em>오픈소스마다 다르겠죠?</em></li><li><code>git checkout ~</code></li><li>영차-영차- 작업 중..</li><li><code>git add ~</code></li><li><code>git commit</code> : <em>커밋 작성법도 나와 있을 수 있으니, 다시 한 번 확인</em></li><li><code>git push origin ~</code></li><li>issue 등록 : <em>이슈 역시 작성법이 있을 수 있으니, 또 확인</em></li><li>Pull Request : <em>Compare&amp;pull request 눌러도 상관 없습니다</em></li><li>끝 :) </li></ol><br><p>받아줄런지 말런지는 모르겠지만,<br>이런 경험을 해봤다는게 저한텐 큰 자산이고,<br>무엇보다 이번 일을 통해서 얼른 오픈소스 기능 개발에 참여하고 싶어졌습니다.<br>기여한다는건 무척 설레는 일이군요 ㅠㅠ   </p><p>엄청난 동기부여.  </p>]]></content>
    
    
    <categories>
      
      <category>TIL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>github</tag>
      
      <tag>opensource</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TIL-swift-Closure-191115</title>
    <link href="undefined2019/11/TIL-swift-Closure-191115/"/>
    <url>2019/11/TIL-swift-Closure-191115/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Closure 기초까지만.</p></blockquote><br><h1 id="Snippet"><a href="#Snippet" class="headerlink" title="Snippet"></a>Snippet</h1><br><p>쉽게 말해 코드 틀을 자동완성 시켜주는 기능입니다. </p><br><ul><li>Editor &gt; Create Code Snippet 에 여러가지 Snippet이 있습니다.</li><li>만드는 방법 :<ol><li>코드창에서 만들고 싶은 코드를 긁은 블록으로 긁은 다음</li><li>1번에서처럼 눌러 들어가거나, 플레이그라운드 경우 오른쪽 상단에 [+] 버튼을 누릅니다.</li><li>Snippet의 이름, 설명, 언어, 플랫폼 등 설정하는데 Completion 부분은 단축어 설정입니다.</li></ol></li><li>이렇게 저장한 Snippet은 <code>~/Library/Developer/Xcode/UserData/CodeSnippets</code>에 있습니다.</li><li>IDE 안에서 설정한 Snippet과 이름이 다르게 저장되어 있으니, 폴더-파일 관리를 하고 싶으실 경우 파일 이름을 바꿔주세요. </li></ul><br><hr><h1 id="Closure"><a href="#Closure" class="headerlink" title="Closure"></a>Closure</h1><br><p>클로저는 다음 3가지 중 한 가지 유형을 가집니다.</p><br><ul><li>Global functions: 이름을 가지며, 어떤 값도 캡쳐하지 않는 클로저</li><li>Nested functions: 이름을 가지며, 감싸고 있는 함수의 값을 캡쳐하는 클로저</li><li>Closure: 주변 문맥(Context)의 값을 캡쳐할 수 있으며, 간단한 문법으로 쓰여진 이름 없는 클로저</li></ul><br><p>오늘는 Closure 한정으로 배웁니다.  </p><br><p>Closure를 쓰는 이유.  </p><ul><li>문법 간소화 / 읽기 좋은 코드</li><li>지연 생성 (lazy… )</li><li>주변 컨텍스트의 값을 캡쳐하여 작업 수행 가능 ( &lt;- 나중에 배움!) </li></ul><br><pre><code class="swift"> Closure Expression Syntax { &lt;#(parameters)#&gt; -&gt; &lt;#return type#&gt; in   &lt;#statements#&gt; }</code></pre><pre><code class="swift">// 클로저를 변수에 담아 이름 부여 가능let closure = {  print(&quot;This is a closure.&quot;)}closure()// 함수도 변수로 저장 가능var function = aFunctionfunction()// 같은 타입일 경우 함수나 클로저 관계없이 치환 가능function = closurefunction()</code></pre><br><h2 id="🌱-풀어보기"><a href="#🌱-풀어보기" class="headerlink" title="🌱 풀어보기"></a>🌱 풀어보기</h2><br><pre><code class="swift">// 1번 문제 예.   &quot;Swift&quot; -&gt; 5// 2번 문제 예.   5 -&gt; 6--let q1 = { (parami: String) -&gt; Int in    return parami.count}q1(&quot;Swift&quot;)// 최적화 -&gt; let q1 = (String) -&gt; Int = { $0.count }let q2 = { (num: Int) -&gt; Int in    return num + 1}q2(q1(&quot;Swift&quot;))</code></pre><br><h2 id="Syntax-Optimization"><a href="#Syntax-Optimization" class="headerlink" title="Syntax Optimization"></a>Syntax Optimization</h2><br><p>Swift 클로저 문법 최적화</p><ul><li><p>문맥을 통해 매개변수 및 반환 값에 대한 타입 추론</p></li><li><p>단일 표현식 클로저에서의 반환 키워드 생략</p></li><li><p>축약 인수명</p></li><li><p>후행 클로저 문법</p><br></li></ul><p>줄이는 과정…</p><pre><code class="swift"> func performClosure(param: (String) -&gt; Int) {  param(&quot;Swift&quot;)} performClosure(param: { (str: String) -&gt; Int in  return str.count})performClosure(param: { (str: String) in  return str.count})performClosure(param: { str in  return str.count})performClosure(param: {  return $0.count // 파라미터 첫 번째})performClosure(param: {  $0.count})performClosure(param: ) {  $0.count}performClosure() { // 하나밖에 없거나, 맨 끝에 있는 파라미터는 생략 가능  $0.count}performClosure { $0.count }</code></pre><br><h2 id="Trailing-Closure"><a href="#Trailing-Closure" class="headerlink" title="Trailing Closure"></a>Trailing Closure</h2><ul><li>함수의 괄호가 닫힌 후에도 인수로 취급되는 클로저</li><li>함수의 마지막 인수에만 사용 가능하며, 해당 인수명은 생략</li><li>하나의 라인에 다 표현하지 못할 긴 클로져에 유용 </li></ul><pre><code class="swift">closureParamFunction(closure: {  print(&quot;Inline closure - Explicit closure parameter name&quot;)})closureParamFunction() {  print(&quot;Trailing closure - Implicit closure parameter name&quot;)}closureParamFunction {  print(&quot;Trailing closure - Implicit closure parameter name&quot;)}</code></pre><br><h2 id="🌱-풀어보기-1"><a href="#🌱-풀어보기-1" class="headerlink" title="🌱 풀어보기"></a>🌱 풀어보기</h2><pre><code class="swift">// 1. 정수를 하나 입력받아 2의 배수 여부를 반환하는 클로져// 2. 정수를 두 개 입력 받아 곱한 결과를 반환하는 클로져--let q3 = { $0 % 2 == 0 }let q4 = (Int, Int) -&gt; Int = { $0 * $1 }</code></pre>]]></content>
    
    
    <categories>
      
      <category>TIL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>swift</tag>
      
      <tag>closure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TIL-swift-Optional+Enum-191114</title>
    <link href="undefined2019/11/TIL-swift-Optional-Enum-191114/"/>
    <url>2019/11/TIL-swift-Optional-Enum-191114/</url>
    
    <content type="html"><![CDATA[<h1 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h1><p>값이 없다. nil<br>0은 데이터.</p><p>옵셔널 타입의 2가지 가능성<br>    1. 값이 전혀 없음<br>    2. 값이 있으며, 그 값에 접근하기 위해 옵셔널을 벗겨냄(unwrap)</p><br><pre><code class="swift">let possibleNumber = &quot;123&quot;var convertedNumber = Int(possibleNumber)type(of: convertedNumber) //Optional&lt;Int&gt;.type</code></pre><p>possibeNumber가 값이 있을 수도 있고, 없을 수도 있기 때문에<br>Int로 형변환이 될 수도 있고 안될 수도 있기 때문에<br>convertedNumber에 대입하면 타입은 옵셔널이 된다.</p><br><pre><code class="swift">// Optional Type Declaration var variable name: Type? var variable name: Optional&lt;Type&gt;</code></pre><br><pre><code class="swift">//Error!var nonOptional1 = nilvar nonOptional2: Int = nil var nonOptionalType: Int = optionalInt</code></pre><p>옵셔널 타입일 때 nil 대입이 된다.<br>옵셔널 타입을 꼭 명시해주어야 한다.</p><br><p>Optinal : Int와 nil 값 중 하나를 갖는다.<br>NonOptional : 오직 Int 값만 갖는다.<br>Optional -&gt; NonOptional (X).<br>Optional &lt;- NonOptional (O).  </p><h2 id="Optinal-Binding"><a href="#Optinal-Binding" class="headerlink" title="Optinal Binding"></a>Optinal Binding</h2><br><pre><code class="swift">// Optional Binding - let vs varvar optionalStr: String? = &quot;Hello, Optional&quot;// letif let optionalStr = optionalStr {//  optionalStr += &quot;😍&quot;  optionalStr} else {  &quot;valueless string&quot;}// varif var str = optionalStr {  str += &quot;😍&quot;  str}</code></pre><br><pre><code class="swift">if let nonOptional = OptionalExpression {   Code } while let nonOptional = OptionalExpression {   Code } guard let nonOptional = OptionalExpression else {   Code }</code></pre><ul><li>바인딩 되지 않은 옵셔널끼리 계산 안된다.</li><li>옵셔널이 아닌 값에 if let 구문쓰면 컴파일 오류난다.</li><li>가장 많이 쓰는 것: guard let</li></ul><br><pre><code class="swift">// 여러 개의 옵셔널 바인딩과 불리언 조건을 함께 사용 가능if let firstNumber = Int(&quot;4&quot;),  let secondNumber = Int(&quot;42&quot;),  firstNumber &lt; secondNumber,  secondNumber &lt; 100 {  print(&quot;\(firstNumber) &lt; \(secondNumber) &lt; 100&quot;)}// 위와 동일한 동작if let firstNumber = Int(&quot;4&quot;) {  if let secondNumber = Int(&quot;42&quot;) {    if firstNumber &lt; secondNumber, secondNumber &lt; 100 {      print(&quot;\(firstNumber) &lt; \(secondNumber) &lt; 100&quot;)    }  }}</code></pre><h2 id="Froced-Unwrapping"><a href="#Froced-Unwrapping" class="headerlink" title="Froced Unwrapping"></a>Froced Unwrapping</h2><br><pre><code class="swift">let nonOptional = OptionalExpression!</code></pre><ul><li>느낌표를 붙여서 강제 언랩핑</li><li>가능하면 쓰지 않도록 합니다.</li></ul><br><h2 id="IUO-Implicityl-Unwrapped-Optionals"><a href="#IUO-Implicityl-Unwrapped-Optionals" class="headerlink" title="IUO (Implicityl Unwrapped Optionals) ?????"></a>IUO (Implicityl Unwrapped Optionals) ?????</h2><br><pre><code class="swift">var assumedString: String! = &quot;An implicitly unwrapped optional string.&quot;let implicitString: String = assumedStringlet stillOptionalString = assumedStringtype(of: assumedString)type(of: implicitString)type(of: stillOptionalString)print(assumedString)print(assumedString!)//assumedString = nil//print(assumedString!)</code></pre><ul><li>옵셔널 타입인데, 반드시 값이 있는 옵셔널 타입이다.</li><li>추후 어느 순간에서라도 nil 이 될 수 있는 경우에는 이 것을 사용하지 말아야 함</li><li>nil value 를 체크해야 할 일이 생길 경우는 일반적인 옵셔널 타입 사용</li><li>프로퍼티 지연 초기화에 많이 사용</li></ul><br><h2 id="Nil-coalescing-Operator"><a href="#Nil-coalescing-Operator" class="headerlink" title="Nil-coalescing Operator"></a>Nil-coalescing Operator</h2><br><pre><code class="swift">optionalStr = nilvar result = &quot;&quot;if optionalStr != nil {   result = optionalStr!} else {   result = &quot;This is a nil value&quot;}// 위와 같음let anotherExpression = optionalStr ?? &quot;This is a nil value&quot;// 사용 예시let defaultColorName = &quot;red&quot;var userDefinedColorName: String?var colorNameToUse = userDefinedColorName ?? defaultColorNameprint(colorNameToUse)userDefinedColorName = &quot;green&quot;colorNameToUse = userDefinedColorName ?? defaultColorNameprint(colorNameToUse)</code></pre><br><h2 id="Optional-Chaining"><a href="#Optional-Chaining" class="headerlink" title="Optional Chaining"></a>Optional Chaining</h2><br><pre><code class="swift">let greeting: [String: String] = [  &quot;John&quot;: &quot;Wassup&quot;,  &quot;Jane&quot;: &quot;Morning&quot;,  &quot;Edward&quot;: &quot;Yo&quot;,  &quot;Tom&quot;: &quot;Howdy&quot;,  &quot;James&quot;: &quot;Sup&quot;]print(greeting[&quot;John&quot;])print(greeting[&quot;John&quot;]?.count)print(greeting[&quot;NoName&quot;])// Optional Chainingprint(greeting[&quot;John&quot;]?.lowercased().uppercased())print(greeting[&quot;Alice&quot;]?.lowercased().uppercased())// Optional Bindingif let greetingValue = greeting[&quot;John&quot;] {  print(greetingValue.lowercased().uppercased())}</code></pre><p>값이 옵셔널일 경우, 해당 값(변수나 등등)의 메소드 사용 출력도 옵셔널 타입.</p><p>옵셔널 바인딩으로 풀어주면 뒤에 값들도 모두 풀린다.</p><br><pre><code class="swift">var optionalArr1: [Int]? = [1,2,3] // Optional&lt;Array&lt;Int&gt;&gt;var optionalArr2: [Int?] = [1,2,3] // Array&lt;Optional&lt;Int&gt;&gt;</code></pre><p>Array가 옵셔널 타입<br>Array안에 담길 자료형이 옵셔널 타입</p><br><h2 id="Optional-Function-Types"><a href="#Optional-Function-Types" class="headerlink" title="Optional Function Types"></a>Optional Function Types</h2><br> <blockquote><p>좀 더 공부해서 추가하기</p></blockquote><br><h2 id="풀어보기"><a href="#풀어보기" class="headerlink" title="풀어보기"></a>풀어보기</h2><pre><code class="swift">/*2개의 정수를 입력받아 Modulo 연산(%)의 결과를 반환하는 함수를 만들되2번째 파라미터와 결과값의 타입은 옵셔널로 정의.두 번째 파라미터 입력값으로 nil 이나 0이 들어오면 결과로 nil을 반환하고, 그 외에는 계산 결과 반환*/</code></pre><br><h3 id="참고-코드"><a href="#참고-코드" class="headerlink" title="참고 코드"></a>참고 코드</h3><pre><code class="swift">func calculateModulo(op1: Int, op2: Int?) -&gt; Int? {  guard let op2 = op2, op2 != 0 else { return nil }  return op1 % op2}</code></pre><br><hr><br><h1 id="Enumerations"><a href="#Enumerations" class="headerlink" title="Enumerations"></a>Enumerations</h1><br><pre><code class="swift">enum CompassPoint {  case north  case south  case east  case west}var directionToHead1 = CompassPoint.westdirectionToHead1 = .eastvar directionToHead2: CompassPoint = .north</code></pre><ul><li>열거형 타입의 이름은 Pascal Case</li><li>각각의 case는 Camel Case</li><li>반환 시 옵셔널 값으로 나온다.</li></ul><br><h2 id="Matching-Enumeration-Values"><a href="#Matching-Enumeration-Values" class="headerlink" title="Matching Enumeration Values"></a>Matching Enumeration Values</h2><br><pre><code class="swift">let directionToHead = CompassPoint.southswitch directionToHead {case .north:  print(&quot;Lots of planets have a north&quot;)case .south:  print(&quot;Watch out for penguins&quot;)case .east:  print(&quot;Where the sun rises&quot;)case .west:  print(&quot;Where the skies are blue&quot;)}let enumTypeAnnotation: Planet = .marslet somePlanet = Planet.earthswitch somePlanet {case .earth:  print(&quot;Mostly harmless&quot;)default:  print(&quot;Not a safe place for humans&quot;)}</code></pre><ul><li>enum과 switch문을 함께 쓰는 경우가 많다.</li></ul><br><h2 id="Associated-Values"><a href="#Associated-Values" class="headerlink" title="Associated Values"></a>Associated Values</h2><br><pre><code class="swift">enum OddOrEven {  case odd(Int) // Int 타입의 값을 받을 수 있다.  case even(Int)}var number = OddOrEven.even(20)number = OddOrEven.odd(13)numbertype(of: number)switch number {case .odd(let x): print(&quot;홀수 :&quot;, x)case .even(let x): print(&quot;짝수 :&quot;, x)}switch number {case let .odd(x): print(&quot;홀수 :&quot;, x)case let .even(x): print(&quot;짝수 :&quot;, x)</code></pre><pre><code class="swift">enum Barcode {  case upc(Int, Int, Int, Int)  case qrCode(String)}var productBarcode = Barcode.upc(8, 85909, 51226, 3)productBarcode = .qrCode(&quot;ABCDEFGHIJKLMNOP&quot;)productBarcodetype(of: productBarcode)switch productBarcode {case let .upc(numberSystem, manufacturer, product, check):  print(&quot;UPC: \(numberSystem), \(manufacturer), \(product), \(check).&quot;)case let .qrCode(productCode):  print(&quot;QR code: \(productCode).&quot;)</code></pre><br><h2 id="Raw-Value"><a href="#Raw-Value" class="headerlink" title="Raw Value"></a>Raw Value</h2><br><ul><li>Stirng, Characters, Int, Float, Double Type</li><li>Enum 내에서 반드시 고유한 값</li></ul><br><pre><code class="swift">// 1enum WeekdayAgain: Int {    case sunday = 5, monday, tuesday, wednesday, thursday, friday, saturday   }WeekdayAgain.sundayWeekdayAgain.sunday.rawValueWeekdayAgain.wednesdayWeekdayAgain.wednesday.rawValue// 2enum WeekdayAgain: Int {    case sunday, monday = 100, tuesday = 101, wednesday, thursday, friday, saturday}WeekdayAgain.sundayWeekdayAgain.sunday.rawValue // 0WeekdayAgain.wednesdayWeekdayAgain.wednesday.rawValue</code></pre><ul><li>다른 case rawValue가 Int일 때, 제일 앞에 있는 case에 rawValue가 지정되어 있지 않으면 자동으로 값은 0이다.</li></ul><br><h2 id="Nested"><a href="#Nested" class="headerlink" title="Nested"></a>Nested</h2><br><pre><code class="swift">enum Wearable {  enum Weight: Int {    case light = 1    case heavy = 2  }  enum Armor: Int {    case light = 2    case heavy = 4  }  case helmet(weight: Weight, armor: Armor)  case boots  func info() -&gt; (weight: Int, armor: Int) {    switch self {    case .helmet(let weight, let armor):      return (weight: weight.rawValue * 2, armor: armor.rawValue * 5)    case .boots:      return (3, 3)    }  }}Wearable.bootsvar woodenHelmet = Wearable.helmet(weight: .light, armor: .heavy)woodenHelmet.info()</code></pre><br><h2 id="Mutating"><a href="#Mutating" class="headerlink" title="Mutating"></a>Mutating</h2><br><p>enum 내부 함수에서 자기 자신의 값을 변경해야 할 경우 mutating 키워드 필요</p><pre><code class="swift">enum Location {  case seoul, tokyo, london, newyork  mutating func travelToTokyo() {    self = .london  }}var location = Location.seoullocationlocation.travelToTokyo()location  // london</code></pre><p>Mutating은 자주 쓰는 방법은 아니라고 하네요.<br>이걸 쓴다고 (당연히) enum case 값이 바뀌는 건 아닙니다.<br>case를 할당 받은 변수의 값이 바뀝니다.</p><br><h3 id="🌱-풀어보기"><a href="#🌱-풀어보기" class="headerlink" title="🌱 풀어보기"></a>🌱 풀어보기</h3><br><pre><code class="swift">enum RemoteControl {    case on    case off    mutating func onToOff() {        self = .off    }    mutating func OffToOn() {        self = .on    }}var switchOn = RemoteControl.offswitchOn.OffToOn()switchOn</code></pre><br><h2 id="Recursive-Enumerations"><a href="#Recursive-Enumerations" class="headerlink" title="Recursive Enumerations"></a>Recursive Enumerations</h2><br><p>자기 자신을 참조한다.<br>indirect 키워드를 붙여야 하는데,<br>case와 enum 둘 다 붙일 수 있습니다.</p><br><pre><code class="swift">indirect enum ArithmeticExpression {  case number(Int)  case addition(ArithmeticExpression, ArithmeticExpression)  case multiplication(ArithmeticExpression, ArithmeticExpression)}</code></pre><br><p>이게.. 재귀함수처럼 쓰이는 건가 본데.. 이해가 잘 되지 않아서 설명할 수 없습니다 …<br>무슨 얘기인지는 대충 알겠지만, 사용은 할 수 없는 …<br>나중에 재귀함수 배우면서 재귀에 대한 개념을 잡고 다시 봐야할 것 같아요!<br>아무튼 이런 것이 있다 정도까지만.</p>]]></content>
    
    
    <categories>
      
      <category>TIL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>swift</tag>
      
      <tag>optional</tag>
      
      <tag>enum</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TIL-swift-collection-191113</title>
    <link href="undefined2019/11/TIL-swift-191113/"/>
    <url>2019/11/TIL-swift-191113/</url>
    
    <content type="html"><![CDATA[<h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><br><ul><li><p>Value Type (Swift Collection)</p><ul><li>Array</li><li>Dictionary</li><li>Set</li></ul></li><li><p>Object Type (Foundaiton Collection)</p><ul><li>NSArray, NSMutableArray</li><li>NSDictionary, NSMutableDictionary</li><li>NSSet, NSMutableSet</li></ul></li><li><p>Copy-on-Write Optimization</p></li><li><p>Generic Collection</p></li><li><p>Mutablility</p><ul><li>let -&gt; Immutable Collection</li><li>var -&gt; Mutable Collection</li></ul></li></ul><br><p>이번 시간에 배운 내용은 Value Type 입니다.<br>미리 예습을 해서 아는 내용<br>..인 줄 알았지?<br>… 진짜 봐서 아는 것과 사용하는 것의 차이가 너무 큽니다..ㅠㅠ  </p><br><p>아무튼 정의를 요약 하자면,<br>Array - ordered collection of values.<br>배열 - 순서가 있고, 인덱스로 분류 되기 때문에 중복 값이 있을 수 있다.<br>Set - unordered collection of unique values.<br>집합 - 순서가 없고, 중복 값이 없다.<br>Dictionary - unorderd collection of key-value - associations.<br>딕셔너리 - 순서가 없고, 키-값의 쌍으로 이루어져있다.  </p><br><p>이 정의를 갖고 코드로 자세히 공부합니다. </p><br><hr><h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><ul><li>Ordered Collection</li><li>Zero-based Integer </li></ul><br><h3 id="Initialize"><a href="#Initialize" class="headerlink" title="Initialize"></a>Initialize</h3><p>컬렉션 타입들은 컬렉션 안에 어떤 데이터 타입이 들어갈 지 지정을 해야 합니다. </p><pre><code class="swift">var arr: [String] = [] // Error!var arr1 : [String] = []var arr2 : Array&lt;String&gt; = [String]()var arr3 : [String] = Array()var arr4 : Array&lt;String&gt; = []</code></pre><p>선언 및 초기화 하는 방법은 많으니, 본인 취향의 선언 방법을 선택한 뒤 나중에 협업할 때는 협업 규칙에 따르면 좋을 것 같아요.<br>저는 <code>var arr1: [String] = []</code> 이 가장 편한 것 같아요.  </p><br><h3 id="method"><a href="#method" class="headerlink" title="method"></a>method</h3><p>주로 배열에서 쓰게 될 메소드들의 모음입니다.  </p><br><h4 id="Count"><a href="#Count" class="headerlink" title="Count"></a>Count</h4><pre><code class="swift">let alpha = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]let countOfAlpha = alpha.count</code></pre><h4 id="Find-Value-of-Index"><a href="#Find-Value-of-Index" class="headerlink" title="Find Value of Index"></a>Find Value of Index</h4><pre><code class="swift">alpha[0]alpha[4]alpha.startIndex // 0alpha[alpha.startIndex] // &quot;a&quot;alpha.endIndex // &quot;c&quot;가 아닌 그 다음, 즉 없는 값이므로 Error!alpha.endIndex-1 // 2alpha[alpha.endIndex-1] // c</code></pre><h4 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h4><pre><code class="swift">if alpha.contains(&quot;a&quot;) {    print(&quot;It&#39;s a&quot;)}if alpha.contains(where: { str -&gt; Bool in    return str == &quot;a&quot;}) {    print(&quot;It&#39;s a&quot;)if let index = alpha.firstIndex(of: &quot;c&quot;) {    print(&quot;index if c : \(index)&quot;)}</code></pre><h4 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h4><pre><code class="swift">var menu: [String] = []// 1menu = [&quot;치킨&quot;]// 2menu.append[&quot;피자&quot;]// 3menu += [&quot;떡볶이&quot;]var beverage = [&quot;아이스라떼&quot;, &quot;무조건아이스라떼&quot;]menu + beverage // 치킨, 피자, 떡볶이, 아이스라떼, 무조건아이스라떼</code></pre><h4 id="Change"><a href="#Change" class="headerlink" title="Change"></a>Change</h4><pre><code class="swift">menu = [&quot;광어&quot;, &quot;연어&quot;, &quot;우럭&quot;]menu[2] = &quot;참치&quot;menu = [&quot;광어&quot;, &quot;연어&quot;, &quot;우럭&quot;, &quot;참치&quot;, &quot;도미&quot;]menu[2...] = [&quot;새우&quot;, &quot;장어&quot;]menu // 광어, 연어, 새우, 장어</code></pre><h4 id="Remove"><a href="#Remove" class="headerlink" title="Remove"></a>Remove</h4><pre><code class="swift">menu = [&quot;이거&quot;, &quot;저거&quot;, &quot;그거&quot;]let removed = menu.remove(at: 0) // remove 메소드는 반환하기 때문에 대입이 가능하다.menu.removeAllalpha = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]if let indexC  alpha.fistIndex(of: &quot;c&quot;) { // 만약 &quot;c&quot;가 중복일 때, 가장 앞에 있는 &quot;c&quot;를 지운다. &lt;-&gt; lastIndex    alpha.remove(at: indexC}    </code></pre><h4 id="Sorting"><a href="#Sorting" class="headerlink" title="Sorting"></a>Sorting</h4><pre><code class="swift">alpha.sort()alpha.sorted()alpha.sorted { $0 &gt; $01 } alpha.sorted(by: &gt;)alpha.shuffle()alpha.shuffled()</code></pre><h4 id="Enumerating"><a href="#Enumerating" class="headerlink" title="Enumerating"></a>Enumerating</h4><pre><code class="swift">var alpha = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]for value in alpha {    if let index = alpha.firstIndex(of: value) {        print(&quot;\(index) - \(value)&quot;)    }}for tuple in alpha.enumerated() {    print(&quot;\(tuple.0) - \(tuple.1)&quot;)}for (index, element) in alpha.enumerated() {    print(&quot;\(index) - \(element)&quot;)}for (index, element) in alpha.reversed().enumerated() {    print(&quot;\(index) - \(element)&quot;)}    </code></pre><br><hr><h3 id="🌱-풀어보기"><a href="#🌱-풀어보기" class="headerlink" title="🌱 풀어보기"></a>🌱 풀어보기</h3><pre><code class="swift">// [&quot;p&quot;, &quot;u&quot;, &quot;p&quot;, &quot;p&quot;, &quot;y&quot;] 라는 값을 가진 배열에서 마지막 &quot;p&quot; 문자 하나만 삭제하기// 정수 타입의 배열을 2개 선언하고 두 배열의 값 중 겹치는 숫자들로만 이루어진 배열 만들기// 정수 타입의 배열을 선언하고 해당 배열 요소 중 가장 큰 값을 반환하는 함수</code></pre><br><hr><br><h2 id="Dictionary"><a href="#Dictionary" class="headerlink" title="Dictionary"></a>Dictionary</h2><pre><code class="swift">let dic1: Dictionary&lt;String, Int&gt; = [:]let dic2: [String: String] = [:]let dic3 = [&quot;a&quot; : 1, &quot;b&quot; : 2]</code></pre><h3 id="Initialize-1"><a href="#Initialize-1" class="headerlink" title="Initialize"></a>Initialize</h3><h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><h4 id="Count-1"><a href="#Count-1" class="headerlink" title="Count"></a>Count</h4><pre><code class="swift">var alpha = [&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3]alpha.countalpha.isEmpty</code></pre><h4 id="Find-Value-of-Key"><a href="#Find-Value-of-Key" class="headerlink" title="Find Value of Key"></a>Find Value of Key</h4><pre><code class="swift">alpha[&quot;a&quot;]alpha[&quot;z&quot;] // nil, 옵셔널 타입으로 반환// 옵셔널 벗겨서 값에 대입하기if let aValue = alpha[&quot;a&quot;] {   // alpha 딕셔너리에 &quot;a&quot;키에 값이 있다면 aValue에 대입한다.    print(aValue)} else {    print(&quot;is empty&quot;}print(alpha.keys)print(alpha.values)let keys = Array(alpha.keys)let values = Array(alpha.values)</code></pre><h4 id="Enumerating-1"><a href="#Enumerating-1" class="headerlink" title="Enumerating"></a>Enumerating</h4><pre><code class="swift">for (key, value) in alpha {    print(&quot;\(key): \(value)&quot;)}for (key, _) in alpha {    print(&quot;key :&quot;, key)}for (_, value) in alpha {    print(&quot;Value: &quot;, value)}for value in alpha.values {    print(&quot;Value :&quot;, value)}</code></pre><h4 id="Search-1"><a href="#Search-1" class="headerlink" title="Search"></a>Search</h4><pre><code class="swift">for (key, _) in alpha {    if key == &quot;a&quot; {        print(&quot;a&quot;)    }}if alpha.contains(where: { (key, value) -&gt; Bool in    return key == &quot;a&quot;    }) {    print(&quot;a&quot;)}</code></pre><h4 id="Add-1"><a href="#Add-1" class="headerlink" title="Add"></a>Add</h4><pre><code class="swift">var some = [&quot;aaa&quot; : 100]some[&quot;aaa&quot;] = 000 // 값 교체some[&quot;bbb&quot;] = 100 // key-value 교체some[&quot;bbb&quot;] = 200 // 값 교체</code></pre><br><h4 id="Change-1"><a href="#Change-1" class="headerlink" title="Change"></a>Change</h4><pre><code class="swift">var change = [String:String]()change[&quot;a&quot;] = &quot;a1&quot;if let value = change.updateValue(&quot;가&quot;, forKey: &quot;a&quot;) {    print(value, change[&quot;a&quot;]!)} else {}if let value = change.updateValue(&quot;하&quot;, forKey: &quot;z&quot;) {    print(value, change[&quot;z&quot;]!)} else {}</code></pre><p>이해해서 사용하기 힘들었던 개념 중 하나!</p><br><p>이렇게 사용할 수 있습니다.</p><ul><li>키가 없을 때<ul><li>키만 추가해서 데이터는 nil 값으로    </li><li>키와 데이터 모두 추가</li></ul></li><li>키가 있을 때 <ul><li>값 변경, 이전 값은 반환</li></ul></li></ul><br><h4 id="Remove-1"><a href="#Remove-1" class="headerlink" title="Remove"></a>Remove</h4><pre><code class="swift">var info = [&quot;person1&quot;: 100, &quot;person2&quot;: 200, &quot;person3&quot;: 300]info[&quot;person1&quot;] = nil // 값이 없어지면 키도 없어진다info[&quot;person5&quot;] = nil // 없는 키이므로 무시된다.let removedValue = info.removeValue(forKey: &quot;person1&quot;)info.removeAll()</code></pre><br> <h4 id="Nested"><a href="#Nested" class="headerlink" title="Nested"></a>Nested</h4><pre><code class="swift">var dict1 = [String: [String]]()dict1[&quot;arr1&quot;] = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]dict1[&quot;arr2&quot;] = [&quot;D&quot;, &quot;E&quot;, &quot;F&quot;]dict1var dict2 = [String: [String: String]]()dict2[&quot;user&quot;] = [  &quot;name&quot;: &quot;나개발&quot;,  &quot;job&quot;: &quot;iOS 개발자&quot;,  &quot;hobby&quot;: &quot;코딩&quot;,]dict2// 서로 다른 타입을 다루기 - as [String: Any][  &quot;name&quot;: &quot;나개발&quot;,  &quot;job&quot;: &quot;iOS 개발자&quot;,  &quot;age&quot;: 20,  &quot;hobby&quot;: &quot;코딩&quot;,  &quot;apps&quot;: [    &quot;이런 앱&quot;,    &quot;저런 앱&quot;,    &quot;잘된 앱&quot;,    &quot;망한 앱&quot;,  ],  &quot;teamMember&quot;: [    &quot;designer&quot;: &quot;김철수&quot;,    &quot;marketer&quot;: &quot;홍길동&quot;  ]] as [String: Any]</code></pre><br><h3 id="🌱-풀어보기-1"><a href="#🌱-풀어보기-1" class="headerlink" title="🌱 풀어보기"></a>🌱 풀어보기</h3><br><pre><code class="swift">// - Dictionary로 저장되어 있는 시험 성적의 평균 점수 구하기// - Dictionary로 저장된 scores 데이터를 튜플 타입을 지닌 배열로 변환하여 저장하기// - 주어진 자료를 보고 Dictionary 자료형에 맞게 데이터를 변수에 저장하기// - 위 문제에서 정의한 변수의 데이터 중 스쿨 배열에 저장된 첫번째 데이터를 꺼내어 출력하기/*&lt;주어진 자료&gt; 패스트캠퍼스  - 스쿨    * iOS 스쿨    * 백엔드 스쿨    * 프론트엔드 스쿨  - 캠프    * A 강의    * B 강의  - 온라인    * C 강의    * D 강의*/</code></pre><p>내가 푼 코드 : </p><p>br&gt;</p><hr><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><ul><li>Unordered Collection</li><li>Unique Value</li><li>Set Literal = Array Literal</li></ul><p>딕셔너리에 비해 중요도가 낮습니다. </p><br><p>간단하게</p><br><pre><code class="swift">let fruitsSet: Set&lt;String&gt; = [&quot;Apple&quot;, &quot;Orange&quot;, &quot;Melon&quot;]let numbers: Set = [1, 2, 3, 3, 3] // {1, 2, 3}let emptySet = Set&lt;String&gt;()</code></pre><br><h4 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h4><ul><li><code>.count</code></li></ul><br><h4 id="Searching"><a href="#Searching" class="headerlink" title="Searching"></a>Searching</h4><ul><li><code>.contains</code></li></ul><ul><li><code>.hasPrefix</code></li></ul><pre><code class="swift">let productSet: Set = [&quot;iPhone&quot;, &quot;iPad&quot;, &quot;Mac Pro&quot;, &quot;iPad Pro&quot;, &quot;Macbook Pro&quot;]for element in productSet {  if element.hasPrefix(&quot;i&quot;) {    print(element)  }}</code></pre><br><h4 id="Add-2"><a href="#Add-2" class="headerlink" title="Add"></a>Add</h4><ul><li><code>insert</code></li></ul><br><h4 id="Remove-2"><a href="#Remove-2" class="headerlink" title="Remove"></a>Remove</h4><ul><li><code>.remove</code></li><li><code>.removeAll()</code></li></ul><br><h4 id="Compare"><a href="#Compare" class="headerlink" title="Compare"></a>Compare</h4><ul><li><code>elementsEqual</code></li></ul><pre><code class="swift">var favoriteFruits1 = Set([&quot;Orange&quot;, &quot;Melon&quot;, &quot;Apple&quot;])var favoriteFruits2 = Set([&quot;Apple&quot;, &quot;Melon&quot;, &quot;Orange&quot;])favoriteFruits1 == favoriteFruits2 // truefavoriteFruits1.elementsEqual(favoriteFruits2) // false</code></pre><ul><li><code>.isSuperset</code></li></ul><pre><code class="swift">let group1: Set = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]let group2: Set = [&quot;A&quot;, &quot;B&quot;]group1.isSuperset(of: group2) // true</code></pre><ul><li><code>.isStrictSuperset</code> 자기 요소 외 추가 요소가 최소 하나 이상 존재할 때</li></ul><pre><code class="swift">group1.isStrictSuperset(of: group2) // truegroup1.isStrictSuperset(of: group1) // false</code></pre><ul><li><code>.isSubset</code></li></ul><pre><code class="swift">group2.isSubset(of: group1) // true</code></pre><ul><li><code>.isStrictSubset</code></li></ul><pre><code class="swift">group2.isStrictSubset(of: group1) // turegroup2.isStrictSubset(of: group2) // false</code></pre><h4 id="Fundamental-Set-Operations"><a href="#Fundamental-Set-Operations" class="headerlink" title="Fundamental Set Operations"></a>Fundamental Set Operations</h4><ul><li>intersection - 교집합</li><li>symmetricDifference - 교집합의 여집합</li><li>union - 합집합</li><li>subtracting - 차집합</li></ul><p>쓸 일이 거의 없다고 해서, 이런 것이 있다 정도만 확인하고<br>더 중요한 배열과 딕셔너리에 집중해봅니다..</p>]]></content>
    
    
    <categories>
      
      <category>TIL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>swift</tag>
      
      <tag>collection-type</tag>
      
      <tag>array</tag>
      
      <tag>dictionary</tag>
      
      <tag>set</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TIL-swift-191111</title>
    <link href="undefined2019/11/TIL-swift-191111/"/>
    <url>2019/11/TIL-swift-191111/</url>
    
    <content type="html"><![CDATA[<h1 id="조건문-제어문"><a href="#조건문-제어문" class="headerlink" title="조건문, 제어문"></a>조건문, 제어문</h1><blockquote><p>github.io 배우기 전 Notion에 정리한 내용 업로드.</p></blockquote><br><h1 id="Conditional-Statements"><a href="#Conditional-Statements" class="headerlink" title="Conditional Statements"></a>Conditional Statements</h1><br><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><pre><code class="swift">if condition {   code } if condition {   statements } else {   statements }</code></pre><br><p>condition 은 Bool 값 (true, false)</p><br><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><pre><code class="swift"> switch value { case value 1:     respond to value 1 case value 2,      value 3:     respond to value 2 or 3 default:     otherwise, do something else }</code></pre><br><p>switch 문은 가능한 모든 사례를 반드시 다루어야 함 (Switch must be exhaustive)</p><br><h3 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h3><ul><li>if문에서는 (&amp;&amp;) == ( , )</li><li>switch문에서는 ( || ) == ( , )</li></ul><br><h2 id="Early-Exit-guard"><a href="#Early-Exit-guard" class="headerlink" title="Early Exit : guard"></a>Early Exit : guard</h2><pre><code class="swift">guard condition else {    code}</code></pre><br><ul><li>조건에 맞지 않으면 바로 종료</li><li>들여쓰기 중첩 방지</li></ul><br><hr><h1 id="Loops"><a href="#Loops" class="headerlink" title="Loops"></a>Loops</h1><br><h2 id="For-in"><a href="#For-in" class="headerlink" title="For - in"></a>For - in</h2><pre><code class="swift">for 루프상수 in items {    code}</code></pre><br><p>🌱 풀어보기</p><pre><code class="swift">// for 문을 이용하여 3의 10제곱에 대한 결과값을 포현// for 문을 이용하여 10부터 1까지 내림차순으로 출력하</code></pre><br><h2 id="While"><a href="#While" class="headerlink" title="While"></a>While</h2><br><ul><li>조건이 거짓이 될 때까지 반복</li></ul><pre><code class="swift">while condition {    code}</code></pre><br><p>🌱 풀어보기</p><pre><code class="swift">// 2~9 사이의 숫자를 입력받아 해당 숫자에 해당하는 구구단</code></pre><br><h2 id="repeat-while"><a href="#repeat-while" class="headerlink" title="repeat ~ while"></a>repeat ~ while</h2><br><ul><li>무조건 한 번은 실행되는 반복문</li></ul><br><pre><code class="swift">repeat {    code} while condition</code></pre><br><p>🌱 풀어보기</p><pre><code class="swift">// 자연수 하나를 입력받아 1부터 해당 숫자 사이의 모든 숫자의 합을 반환</code></pre><br><hr><h1 id="Control-Transfer-Statement"><a href="#Control-Transfer-Statement" class="headerlink" title="Control Transfer Statement"></a>Control Transfer Statement</h1><br><ul><li>특정 코드에서 다른 코드로 제어 이전, 코드 실행 순서 변경한다.</li><li>continue : 반복문에서 사용 / 현재 반복문의 작업을 중단하고 다음 반복 아이템에 대한 작업 수행</li><li>break : 반복문, swith문에서 사용 / break가 포함된 해당 제어문의 흐름을 즉각 중단</li><li>fallthrough : switch문에서 사용 / switch case의 실행이 종료된 후 그 다음 case가 실행되도록 함</li><li>return : 함수에서 사용 / 함수 즉시 종료 및 return type에 해당하는 자료 반환</li></ul><br><h2 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h2><br><p>🌱 풀어보기</p><pre><code class="swift">for num is 0...15 {    if num % 2 == 0 {        continue    }    print (num)}</code></pre><br><h2 id="return"><a href="#return" class="headerlink" title="return"></a>return</h2><br><p>🌱 풀어보기</p><pre><code class="swift">func isEven(num: Int) -&gt; Bool {    if num % 2 ==0 {        return true    }    return false}isEven(num: 1)isEven(num: 2)</code></pre><p>🌱 풀어보기</p><pre><code class="swift">func returnFunction() -&gt; Int {  var sum = 0  for _ in 1...100 {    sum += 20    return sum  }  return 7}print(returnFunction())</code></pre><br><h2 id="break"><a href="#break" class="headerlink" title="break"></a>break</h2><br><p>🌱 풀어보기</p><pre><code class="swift">for i in 1...100 {  print(i)  break}</code></pre><p>🌱 풀어보기</p><pre><code class="swift">for num in 0...8 {  if num % 2 == 0 {    break  }  print(num)}</code></pre><p>🌱 풀어보기</p><pre><code class="swift">for i in 0...3 {  for j in 0...3 {    if i &gt; 1 {      break    }    print(&quot;  inner \(j)&quot;)  }  print(&quot;outer \(i)&quot;)}</code></pre><h2 id="Labeled-Statements"><a href="#Labeled-Statements" class="headerlink" title="Labeled Statements"></a>Labeled Statements</h2><br><p>🌱 풀어보기</p><pre><code class="swift">OUTER: for i in 0 ... 3 {  INNER: for j in 0...3 {    if i &gt; 1 {      print(&quot;j :&quot;, j)      break OUTER    }    print(&quot;  inner \(j)&quot;)  }  print(&quot;outer \(i)&quot;)}</code></pre>]]></content>
    
    
    <categories>
      
      <category>TIL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>swift</tag>
      
      <tag>if</tag>
      
      <tag>switchi</tag>
      
      <tag>for-in</tag>
      
      <tag>while</tag>
      
      <tag>repeat-while</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TIL-git-191111-191112</title>
    <link href="undefined2019/11/TIL-191111-191112/"/>
    <url>2019/11/TIL-191111-191112/</url>
    
    <content type="html"><![CDATA[<h1 id="Git-특강"><a href="#Git-특강" class="headerlink" title="Git 특강"></a>Git 특강</h1><p>강사님 : <a href="https://github.com/ulgoon/essential-git" target="_blank" rel="noopener">https://github.com/ulgoon/essential-git</a></p><h1 id="Repo-add-commit-push"><a href="#Repo-add-commit-push" class="headerlink" title="Repo, add, commit, push"></a>Repo, add, commit, push</h1><pre><code class="shell">mkdir Devgit clone &lt;https://~&gt;lsvi .gitignore// 추가한 내용    hidden/    *.pem    confidential.*git status // modified: .gitignoremkdir hiddentouch hidden/Hello.swifttouch key.pemtouch confidential.swift</code></pre><pre><code>git config --listgit config --global user.name &quot;jisng&quot;git config --global user.email &quot;jxsxxng@gmail.com&quot;git config --global core.editor &quot;vim&quot;git config --global core.pager &quot;cat&quot;git config --list // 변경 된 사항 확인vi README.mdgit status // .gitignore, README.mdgit add .gitignore // 셋팅과 설명은 성격이 다르기 때문에 따로 올리기git commitgit add README.mdgit commit -m &quot;docs: ~&quot;git remote // origingit remote get-url origin // https:~git push origin master</code></pre><p>commit 말머리 작성 </p><ul><li><p>feat : feature</p></li><li><p>conf : configuration</p></li><li><p>fix : bug fix</p></li><li><p>refactor : refactoring</p></li><li><p>docs:</p></li></ul><h2 id="TIL"><a href="#TIL" class="headerlink" title="TIL"></a>TIL</h2><pre><code class="shell">git clone https:~cd TILmkdir gittouch git/191111-git-basic.mdbrew install tree// 레포들이 병렬 상태로 존재할 수 있도록 신경쓴다. (레포 아래 레포가 관리되지 않도록)</code></pre><p>repository들이 병렬 상태로 존재할 수 있게 (레포 아래 레포 관리 되지 않도록) 신경쓰기</p><pre><code>treecd gitvi 191111-git-basic.mdgit statusgit add 191111-git.basic.mdgit commitgit push origin master</code></pre><h1 id="github-io"><a href="#github-io" class="headerlink" title="github.io"></a><a href="http://github.io" target="_blank" rel="noopener">github.io</a></h1><pre><code class="shell">pwdgit clone &lt;https://github.com/jisng/jisng.github.io.git&gt;cd jisng.github.iotouch index.htmlvi index.html&lt;!doctype html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;firt github page&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;h1&gt;Home&lt;/h1&gt;        &lt;p&gt;paragraph&lt;/p&gt;    &lt;/body&gt;&lt;/html&gt;git statusgit add index.htmlgit commit -m &quot;&quot;git push origin master</code></pre><h2 id="github-io-hexo"><a href="#github-io-hexo" class="headerlink" title="github.io + hexo"></a><a href="http://github.io" target="_blank" rel="noopener">github.io</a> + hexo</h2><pre><code>brew install nodenode -vnpm -vsudo npm install -g hexo-clihexopwd // Devhexo init {ghbloc}ls // TIL, ghblog, jisng.github.iocd ghbloglsnpm installhexo new post {start-my-github-blog-with-hexo}// INFO Createde: ~/Documents/Dev/ghblog/source/_posts/start-my-github-blog-with-hexo.mdvi source/_posts/start-my-github-blog-with-hexo.mdhexo generatehexo server // 로컬에서 사이트를 확인할 수 있다npm install --save-dev hexo-deployer-gitvi _config.yml// _config.yml// :set nu 줄 번호가 나온다# Sitetitle:subtitle:description:keywords:author:language:timezone:hexo deploy</code></pre><br><p>제가 여기까지 했을 때, 절차들이 복잡하여 혼란스러웠거든요.<br><br><br>[local-dir]jisng.github.io &lt;-&gt; [github-repo]jisng.github.io 는 연결되어 있다는 걸 알겠는데..  터미널에서 확인해보면 [local-dir]ghblog는 깃관리가 안되는 것처럼 보이는데..  그럼 hexo blog 업로드는 github에 안찍히는건가? 뭐 그런 혼란스러움.. (글도 혼란스러워보이네..)<br><br><br>그래서 폴더들을 열어보면서 순서(?)들을 유추하여 강사님께 확인해서 알아냈습니다!<br>아직 git 쪼랩이라서 디테일하게 알 수는 없었지만, 대강 이렇게 업로드 되는구나~ 정도 파악한 점 고려해주세요..ㅎ<br><br><br>🤨  그럼 업로드 되는 논리를 야매로 이해해봅시다.<br><code>hexo new post {name}</code> 로 포스팅 할 파일을 생성하여<br><code>vi source/_posts/{name}</code> 을 열어서 내용을 작성하여<br><code>hexo clean &amp;&amp; hexo generate</code>, <code>hexo deploy</code>로 포스팅을 올리면<br>[dir]ghblog &gt; [dir]jisng.github.io &gt; [github-repo]jisng.github.io &gt; [hexo-blog]sjisng.github.io<br>의 순서를 거쳐 업로드 된다고 이해할 수 있습니다.<br>진짜 프로그램 처리 순서라고 보기는 어렵지만, 아무튼 저 폴더와 레포를 거친다고 보면 됩니다.</p><br>+<br><p>추가로 [dir]ghblog &gt; public의 폴더 구조가 [repo]jisng.github.io에 반영됩니다.<br><code>[dir]ghblog &gt; source &gt; _posts &gt; md</code> 파일이 hexo에 의해 html로 변환되면 <code>[dir]ghblog &gt; public</code>에 저장된다고 보면 됩니다.<br>날짜별로 폴더가 생성되어 정리가 될텐데, 이 날짜별 폴더는 위에서 <code>ghblog &gt; _config.yml</code> 폴더에서 셋팅한대로 생성됩니다.  </p><br><h1 id="Theme-setting"><a href="#Theme-setting" class="headerlink" title="Theme setting"></a>Theme setting</h1><ol><li>테마 결정</li><li><code>git clone ~</code></li><li><code>vi _config.yml</code> &gt; :93 &gt; theme: {theme-name}</li><li><code>hexo clean &amp;&amp; hexo generate</code></li><li><code>hexo deploy</code> </li></ol><h2 id="Theme-gt-confit-yml"><a href="#Theme-gt-confit-yml" class="headerlink" title="Theme &gt; _confit.yml"></a>Theme &gt; _confit.yml</h2><p>Theme 설치할 때 sudo 명령어로 설치했기 때문에, theme{theme-name} 안의 소유자는 root</p><pre><code class="shell">cd themes/cactusls -l//    &gt; -rw-r--r-- 1 root staff 4666 11 12 10:29 _config.ymlsudo chown jisng cactus/* // cactus의 모든 파일의 소유자를 jisng 으로 바꾼다.cd cactuslsls -l // cactus 폴더 소유자는 root, 내부 파일 소유자는 uservi _config.yml // 테마 설정 바꿈</code></pre><h1 id="branch"><a href="#branch" class="headerlink" title="branch"></a>branch</h1><pre><code class="shell">~/Documents/Dev/gitTestgit branch earth123git branch git checkout earth123git checkout mastergit branch -D eart123 // earth123 branch 삭제</code></pre><h1 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h1><pre><code class="shell">git branch edit-readme // 브랜치 이름만으로 무슨 일을 할 지 유추할 수 있도록 네이밍한다.git chekout edit-readme // README.md 파일 수정 중..git add README.mdgit commit -m &quot;&quot;git checkout mastergit branch // master로 왔는지 재확인git diff edit-readme // 차이 확인git merge edit-readme</code></pre><h1 id="git-flow"><a href="#git-flow" class="headerlink" title="git flow"></a>git flow</h1><ul><li><a href="https://danielkummer.github.io/git-flow-cheatsheet/index.ko_KR.html" target="_blank" rel="noopener">git flow 설치 - 설명 페이지</a></li></ul><pre><code class="shell">git flow initgit flow feature start flow-init // enter -----git branchgit touch main.swiftgit add main.swiftgit commit - m &quot;&quot;git flow feature finish flow-initgit branch // *developgit push origin develop</code></pre><h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip !"></a>Tip !</h2><ul><li><p>bitbucket : 소수 인원(5명)이서 협업할 때 무료로 사용할 수 있다.</p></li><li><p>github - LICENSE</p></li><li><p><code>rm -fr .git</code> 해당 파일을 git 관리 해제한다.</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>TIL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>start-my-github-blog-with-hexo</title>
    <link href="undefined2019/11/start-my-github-blog-with-hexo/"/>
    <url>2019/11/start-my-github-blog-with-hexo/</url>
    
    <content type="html"><![CDATA[<h2 id="hexo-blog"><a href="#hexo-blog" class="headerlink" title="hexo blog"></a>hexo blog</h2><pre><code class="shell">$ brew install node$ npm - v$ sudo npm install -g hexo-cli$ hexo$ hexo init ghblog$ cd ghblog$ npm install$ hexo new post {post-name}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>hexo, git, github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="undefined2019/11/hello-world/"/>
    <url>2019/11/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>